This is a preliminary documentation for HPP, the HTML PreProcessor.

HPP reads normal HTML files, processes some special tags and outputs
a new file which need not be in HTML.

New tags by HPP:

------------------------------------------------------------------------------
<REM remark> and <REM>remark</REM>

This is a comment. Unlike <--...-->, <REM> can nest.

Example:

<REM This remark contains the remark in the tag. No /REM is allowed>

<REM>This is a <REM>nested</REM> remark</REM>

------------------------------------------------------------------------------
<DEF NAME=name [OPTION=opt [DEFAULT=value]]...>text</DEF>

Defines a macro "name" which takes a number of options which may have
default values. If <name...> appears in the source after the definition,
then the arguments are read, then missing arguments are assigned their
default values and then "text" is evaluated. All tags in "text" are
processed and you can access the values of the arguments by "$opt".

You can't define a macro with the same name as a block.

Example:

<DEF NAME=examplemacro OPTION=opt1 DEFAULT=val1 OPTION=opt2>
    You called examplemacro with opt1=$opt1 and opt2=$opt2.
</DEF>

<examplemacro>
<examplemacro opt2=test>

results in

    You called examplemacro with opt1=val1 and opt2=.
    You called examplemacro with opt1=val1 and opt2=test.

------------------------------------------------------------------------------
<BDEF NAME=name [OPTION=opt [DEFAULT=value]]...>text</DEF>

This is similar to a macro but it takes one very long argument which is
stored in $@body.

You can't define a block with the same name as a macro.

Example:

<BDEF NAME=exampleblock OPTION=opt1 DEFAULT=val1 OPTION=opt2>
    You called exampleblock with opt1=$opt1 and opt2=$opt2.<P>

    This is the text you passed to exampleblock: $@body.
</BDEF>

<exampleblock>
This will be passed to exampleblock in body.
</exampleblock>

------------------------------------------------------------------------------
<EDEF NAME=name [BEGIN=text] [END=text]>

This defines an environment. If you define an environment with the same
name as a block or a macro, then the environment will be used if no
arguments appear in the tag (ie. if you give <name> instead of <name
arg=val>).

<EDEF NAME=BTT BEGIN="<B><TT>" END="</TT></B>">

<BTT>test</BTT>

results in

<B><TT>test</TT></B>

------------------------------------------------------------------------------
<IF COND="condition">text1[<ELSE>text2]</IF>

Test condition. If true, then "text1" will be output otherwise "text2" or
nothing (if the else part is missing) will appear in the output.

<IF COND=1>
    This will show up
<ELSE>
    This won't
</IF>

<IF COND=0>
    Nothing will show up
</IF>

results in

    This will show up

------------------------------------------------------------------------------
<FILTER CMD=command [PROCESSINPUT] [EXPANDINPUT] [INPUTFILE] [PROCESSOUTPUT]>

Calls the specified command and passes the contents of $@body to it. This
is most useful in a block.

<FILTER CMD="format -type $type -outformat $outputFormat $infilename"
	VerbatimInput InputFile ProcessOutput>

Calls the external program "format". The various variables are expanded.
The following options are available:

PROCESSINPUT - Read the body and process it before handing it to the filter
    (ie. do the normal HPP job on the input of the filter).

EXPANDINPUT - This is less than PROCESSINPUT; it just expands all
    variables. If you specify both, then this will happen first.

INPUTFILE - Create a variable $infilename and set it to the name of the
    file where the contents of $@body are stored. If you omit this, then
    you'll have to read the body from stdin.

PROCESSOUTPUT - This will make HPP read the output of the command and
    process it. If you omit this, the output of the command is passed
    on by HPP without further modifications.
------------------------------------------------------------------------------
<SET var=val [var2=val2]...>

Modify the values of variables. If you use this in a block or a macro, then
the variable will be deleted afterwards if it didn't already exist.

<SET global=1>

<DEF NAME=settest>
    <SET global=2 local=3>
    $global $local
</DEF>

$global <settest> $global

results in

1 2 3 2
------------------------------------------------------------------------------
<INCLUDE FILE=filename>

Continues with processing the specified file and resumes after the INCLUDE
when the whole file has been processed.
------------------------------------------------------------------------------
<BLOCK name>text</BLOCK>

Creates a big variable name with the contents text.

<BLOCK test>
    This is assigned to the variable test.
</BLOCK>
------------------------------------------------------------------------------
<TEMPLATE NAME=string>text</TEMPLATE>

This uses the information stored in text to create an output file. It
does this as follows: First the text is read and then the template
and the variables defined in the text are replaced in the template.
------------------------------------------------------------------------------
<EXPAND TEXT=string>

Expands string twice and puts them in the output. This is useful if you
have a variable which itself might contain variables.

<SET var1="$var2">
<SET var2="$test">

$var1
<EXPAND TEXT="$var1">

gives

$var2
$test
------------------------------------------------------------------------------
<VERB TEXT=string>

String is inserted verbatim into the output.

<VERB TEXT="<TT>">

gives

<TT>&lt;TT&gt;</TT>
------------------------------------------------------------------------------

