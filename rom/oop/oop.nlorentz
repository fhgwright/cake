
Example for a class which supports plain methods and interfaces.
The class is used as a building block in a filesystem like
database:

    - Objects are sorted hierarchial (ie. there is a path to an
      object like a/b/object)
    - Objects have similar attributes as files (ie. a name, a
      size, a creation date and access flags).
      

#define LISTITEMINTERFACE   "listitem.interface"
#define FILEINTERFACE 	    "file.interface"


enum ListItemMethods
{
    LIM_AddNotify,
    LIM_RemNotify,
    LIM_CheckAccess,
};


struct LIMsg_AddNotify
{
    ULONG		methodID;
    NotificationHandler handler;
};

struct LIMsg_RemNotify
{
    ULONG		methodID;
    NotificationHandler handler;
};

struct LIMsg_CheckAccess
{
    ULONG methodID;
    User  user;
    Group group;
    ULONG accessInfo; // Read, Write, Create, etc.
};



#define FILECLASS   "file.class"

enum FileMethods
{
    FM_Read,
    FM_Write,
    FM_Seek,
    FM_Tell,
};


#define M_Read 	(__I_File + FM_Read)
#define M_Write (__I_File + FM_Write)
#define M_Seek	(__I_File + FM_Seek)
#define M_Tell 	(__I_File + FM_Tell)


#define M_AddNotify	(__I_ListItem + LIM_AddNotify)
#define M_RemNotify	(__I_ListItem + LIM_RemNotify)
#define M_CheckAccess	(__I_ListItem + LIM_CheckAccess)

#define I_File   	(__I_File)
#define I_ListItem   	(__I_ListItem)
/*
When an application uses these, he will get
undefined reference to symbol __I_File, and __I_ListItem,
and he has to initialize thes as global vars
(or inside a library base structure, if they 
are used inside a library) using the GetInterfaceID() call.
*/

The class structure for FILECLASS looks like this:

Class FileClass =
{
    Class *parent;

    // No special doMethod() in this class
    Method doMethod = parent->doMethod;



    // I have own for these
    Method new = FM_New;
    Method delete = FM_Delete;
    Method setAttrs = FM_SetAttrs;
    Method getAttr = FM_GetAttr;
    
    // --------- The below data is PRIVATE -----------
    
    Method *fileMethodTable =
    {
	// Methods of the File interface
	FM_Read,
	FM_Write,
	FM_Seek,
	FM_Tell,
    };
    

    Method * listItemMethodTable =
    {
	// Methods of the ListItem interface
	FM_AddNotify,
	FM_RemNotify,

    };


    Hashtable interfaces;


};


// Create class

// Base ID of an interface
ULONG listItemInterfaceID = GetInterfaceID (LISTITEMINTERFACE)
ULONG fileInterfaceID     = GetInterfaceID (FILEINTERFACE)

Hashtable_Add (FileClass->interfaces, listItemInterfaceID, listItemMethodTable);
Hashtable_Add (FileClass->interfaces, fileInterfaceID, 	   fileMethodTable);


// DoMethod stub:

IPTR DoMethod (Object o, Msg m)
{
    return cl->doMethod (o, m);
}


// parent->doMethod:

// 10 lower bits is the method idx.
#define NUM_METHOD_BITS 10
#define METHOD_MASK ((1 << NUM_METHOD_BITS) - 1)

IPTR xxx_DoMethod (Object o, Msg m)
{
    Method *m_table;
    Class *cl = OCLASS(o);
    
    ULONG interfaceID = m->MethodID & (~METHOD_MASK);
    ULONG m_idx = m->MethodID & METHOD_MASK;
    
    m_table = Hashtable_Find (cl->interfaces, interfaceID);
    
    return m_table[m_idx] (cl, o, m);
}


// --- Stubs

void ListItem_AddNotify (Object o, NotificationHandler handler)
{
    struct LIMsg_AddNotify msg =
    {
	M_AddNotify,
	handler
    };
    return OCLASS(o)->DoMethd(o, msg);
}


ULONG File_Read (Object file, UBYTE * buffer, ULONG count)
{
    struct FMsg_Read msg =
    {
	M_File_Read,
	buffer,
	count
    };

    return OCLASS(o)->DoMethod(o, msg);
}


// definition of interface object

typedef 
{
    // function to call a method in an interface
    IPTR (*CallIF)(Interface *, Msg);
    
    // method table for this specific interface
    Method *MethodTable;
    
    // Object to call methods on.
    Object *TargetObject; 
    
} Interface;

/* Functio for creating an interface object */
Interface *GetInterface(Object *o, ULONG interfaceID)
{
    Interface *if_obj;
    
    // allocate mem for interface object
    
    if (if_obj = AllocMem(sizeof (Interface)))
    {
        // find method table to be used in interface
    	if_obj->MethodTable = Hashtable_Find (OCLASS(o)->interfaces, interfaceID);
	
	// Get default function for calling an interface. (User can override this)
	if_obj->CallIF = StdCallIF;
	
	// save target object
	if_obj->TargetObject = o;
	

    	return if_obj;
    }
    return NULL;
}

// function for calling an interface object
IPTR StdCallIF(Interface *i, Msg m)
{
    return i->MethodTable[m & METHOD_MASK](OCLASS(o), i->TargetObject, m);
}

// How it's used:

ULONG __I_File;
ULONG __I_ListItem;

int main()
{

    if (     __I_File      = GetInterfaceID(FILEINTERFACE)
         &&  __I_ListItem  = GetInterfaceID(LISTITEMINTERFACE)
	 && ...)
    {
    	Object * file = NewObject(FILECLASS, ....);
	if (file)
	{
	    // Get interface object for File interface
	    Interface *file_if = GetInterface(file, I_File);
	    if (file_if)
	    {
	    
	    	...
	    
	    
	    	// Now you can use this interface object to call all
	    	// methods of that interface.

    	    	struct FMsg_Read read_msg =
    	    	{
		    M_File_Read,
		    buffer,
		    count
    	    	};
	    
	    	file_if->CallIF(file_if, &read_msg);
	    
	    	...
	    

    	    	struct FMsg_Write write_msg =
    	    	{
		    M_File_Write,
		    buffer,
		    count
	    	};
	    	file_if->CallIF(file_if, &write_msg);
		
	    }
    
	}
	
    }

}

Pro: - 	Orthogonal, you don't have to take special care
      	to separate between basic and additional interfaces.

Con: - 	Relatively slow normal method invocation, because of
        hashing.
	Compensated for by interface objects, which is generally
	about 1.5 - 2 times faster calling an *empty* method.

     -	Needs to initialize global vars. Could be somewhat
        automated by reading linker output, parsing
	it and generate a source file that does the job.
	Could use a classbase approach instead,
	but then one get into other problems, like
	specifying a methodID from within the app.
	
	Note that in a typical app you wouldn't use that
	many different interfaces, and not that
	many global vars you need to initialize.
