\chapter{Informations for Developers}

\section{Differences between AmigaOS and AROS}

\subsection{Pointer/Integer conversions}

If you need a variable which can store a pointers as an integer, don't use
|ULONG| but |IPTR|. AROS guarantees that |LONG| is 32bit on all systems, while
|IPTR| is always large enough to contain a pointer. Most notable things
which are affected by this: |TagItem|s (the |ti_Data| field is now an |IPTR|
instead of |ULONG|), BOOPSI classes (eg. the return value of |DoMethod()|),
|ReadArgs()|, |VPrintf()|, |VFPrintf()| and more.

\subsection{64bit variables}

The type of 64bit variables is |QUAD| (unsigned: |UQUAD|). This is for example
returned by the function |SMult64()| of utility.library. To access the
high- and loworder 32bit values of the 64bit variable, use |LOW32OF64()|
and |HIGH32OF64()| which are defined in \filename{AROS/include/aros/64bit.h}.

\subsection{Cloning RastPorts}

AROS uses an external driver to access the graphics hardware. Since the
nature of this driver is unknown to AROS, it is no longer valid to clone
a RastPort by simply copying it. To be compatible, there are two new
functions (in AROS) or macros (on Amiga): |CreateRastPort()|,
|CloneRastPort()| and |FreeRastPort()|. You must call |CloneRastPort()| to
create a copy or |CreateRastPort()| for an empty RastPort and
|FreeRastPort()| after you´ve done your work with it.

This approach produces equivalent code on the Amiga but on AROS it can slow
things down a bit. If you must preserve the original state of the RastPort,
it's more safe to create a clone, work on it and then dispose of it again. It
can also be faster if you would have to make a lot of changes to the RastPort
to create two clones and set them to the two states you need. But your code
should not depend on certain gains or losses of speed due to cloned RastPorts
since the behaviour of the underlying graphics system is undefined.

\subsection{Tag values}

The original AmigaOS doesn't use the tags below |USER_TAG| (have a look at
\filename{include:utility/tagitem.h} if you don't belive me) which means, you shouldn't use
tags at or near |USER_TAG| because then they might interfere with the OS's
own tags. To solve this, AROS *does* use the tags *below* |USER_TAG| and the
various implementators need not fear that their tags may overlap with the
ones from the system. The file \filename{AROS/include/utility/tagitem.h} now contains the
basic offsets for the various parts of the OS. In the future, it might be
possible for users to allocate ranges of tags for specific uses.

\subsection{DoMethod() or the stack is all wrong}

There are CPUs around which don't care that the rest of the world have
stacks which grow from large to small adresses. HPPA is an example for
this. While it might look neat to the engineers who did it, it breaks our
code. Another thing which breaks the code are small data types (eg. |WORD|,
|UBYTE|, etc), because most systems put only integers or longs and pointers
on the stack. So if some Msg structure expects |WORD| (see
\filename{include:intuition/gadgetclass.h}), this fails on every system but
the Amiga. Then there are rumours about CPUs which use 32bit numbers and
64bit pointers or the other way round. On these CPUs, |SetAttrs()| and all
other function which pass TagLists over the stack will fail. To overcome
this, we introduce this rule:

\begin{emph}
If you want to pass a structure with |DoMethod()| and |DoMethodA()|
or similar functions, you must prepend |STACK| to each type, like
this: |WORD| becomes |STACKWORD|, |ULONG| becomes |STACKULONG|, etc.
\end{emph}

To solve special problems on certain CPUs, we try to get a compiler which
gets it right or, if that is impossible, we write a small preprocessor
which replaces the dubious code by calls to the array versions.

\subsection{Registers and CPUs}

AROS has put some effort in defining a way to write code which is hardware
independant. To achieve this, a couple of macros have been definied.

\begin{description}
\item{AROS_ASMSYMNAME(n)} Use this macro to access the assembler symbol |n|
from C.

\item{AROS_CSYMNAME(n)} Use this macro to access the C symbol |n| from
assembler.

\item{AROS_CDEFNAME(n)} Use this macro to define the assembler symbol |n|
in such a way that it can be accessed from C.

\item{AROS_SLIB_ENTRY(n,l)} Use this macro to get the name of a function
n which is part of the shared library l.

\item{AROS_UFH#(...)} Use this macro to declare a function which needs its
arguments passed in registers. # is the number of arguments the function
expects. The parameters of the macro are the return type of the function,
its name and the parameters in |AROS_UFHA()| macros. If the function is an
assembler function, you must use the |AROS_ASMSYMNAME()| macro to get it's
name.

\item{AROS_UFHA(t,n,r)} Use this macro to declare a parameter for a
function which is declared with the |AROS_UFH*()| macro. It takes three
arguments: The type of the parameter, the name of the parameter and the
register the parameter is expected in.

\item{AROS_UFC#(...)} Call a function which needs its arguments in
registers. Works the same way as |AROS_UFH*()|.

\item{AROS_LH#[I](...)} Use this macro to declare a function which is part
of a shared library. # is the number of arguments the function expects.
If the function doesn't need the library base passed, you can speed up
things by appending "I" to the macros name. The parameters of the macro are
the return type of the function, its name, the parameters in |AROS_LHA()|
macros, the type of the library, the name of the variable the library base
is passed in, the offset in the function table (1 is the first offset and 5
is the first offset for a user function) and the name of the library.

\item{AROS_LHA(t,n,r)} Use this macro to declare a parameter for a function
which is declared with the |AROS_LH*()| macro. It takes three arguments:
The type of the parameter, the name of the parameter and the register the
parameter is expected in.

\item{AROS_LC#[I](...)} Call a function which is part of a shared library.
Works the same way as |AROS_LH*()|.

\item{AROS_STACK_GROWS_DOWNWARDS} has the value 1 if it is true and 0
otherwise.

\item{AROS_BIG_ENDIAN} has the value 1 if the machine is big endian (eg.
Amiga) or little endian (eg. PCs). Endianess means the way a number is
stored in memory. Amiga stores |0x11223344| as |0x11 0x22 0x33 0x44| in
memory while a PC does it as |0x44 0x33 0x22 0x11|.

\item{AROS_SIZEOFULONG} The result of |sizeof(ULONG)|.

\item{AROS_WORDALIGN} The minimal alignment of 16bit numbers in the memory
of computer (|WORD| and |UWORD|).

\item{AROS_LONGALIGN} The minimal alignment of 32bit numbers in the memory
of computer (|LONG| and |ULONG|).

\item{AROS_PTRALIGN} The minimal alignment of pointers in the memory of
computer (eg. |char *| or |APTR|).

\item{AROS_DOUBLEALIGN} The minimal alignment of 64bit IEEE floating point
numbers in the memory of computer (|double|).

\item{AROS_WORSTALIGN} The worst possible alignment of any data type in the
memory of computer (mostly the same as |AROS_DOUBLEALIGN|).

\item{AROS_ALIGN(x)} Get the next possible address where one can put any
data type. This macro will return |x| if any data type can be put at |x|.
Most of the time, this macro is used like this: Get a buffer, put some data
in it and then use |AROS_ALIGN()| to find out where the next data can be
put.

\item{AROS_SLOWSTACKTAGS} is defined, if you must use |GetTagsFromStack()|
and |FreeTagsFromStack()| instead of just passing the address of the tag of
the first tagitem.

\item{AROS_SLOWSTACKMETHODS} is defined, if you must use
|GetMsgFromStack()| and |FreeMsgFromStack()| instead of just passing the
address of the method ID.

\end{description}

\section{One for all and all for one - CVS}

\label{CVS}CVS is a software to maintain a database which contains the
sources of a project one works on. The software offers a list of commands
to merge the most recent version of the project with the local sources and
to publish changes on has made over the Internet.

\subsection{CVS on Un*x}

If you have Linux or any other Un*x, then all you need is CVS 1.8 or better.
If it's not already on your system (type \shell{cvs} to find out), fetch
if from one of the many GNU mirrors and install it in your \filename{$HOME}.

Then get the AROS developer archive from the AmiNET and compile
\filename{crypt.c} (just say \shell{make crypt}. Think of a good password
and use \filename{crypt} to encode it, like this:

\begin{example}
> make crypt
> crypt my_password
Encrypting my_password: cbEVHg0j9uNRs
\end{example}

Now skip the next section and read on in "How get access to the AROS CVS
server".

\subsection{CVS on Amiga}

If you have an Amiga, you can participate, too. Just get the CVS from
ADE, install it and get the demo for AmiTCP 4.0 (\filename{AmiTCP-demo-40.lha}
in \filename{comm/tcp}) from AmiNET. You also must have
\filename{ixemul.library} 45.0 (should come with ADE) and
\filename{ixnet.library} in \filename{LIBS:}. Then you can create
your password with \filename{crypt} out of the \filename{AROScrypt.lha}
archive from AmiNET (in \filename{dev/misc}) like this:

\begin{example}
> run amitcp:amitcp
[CLI 8]
> crypt my_password
Encrypting my_password: cbEVHg0j9uNRs
\end{example}

(you must have the directory where crypt is stored in, in your path or
you must do this in the same directory where crypt is).

\subsection{How to get access to the AROS CVS server}

Mail the password you have created to me:
\email{digulla@aros.fh-konstanz.de}. The subject must be
\shell{Access to AROS CVS Server} and with this text in the mail:

\begin{example}
Please add <my_login, eg. digulla> <password, eg. cbEVHg0j9uNRs>
\end{example}

Don't forget to fill in the information :-)

Wait until I confirm this. While you wait, look for CVS 1.8 or better if
you haven't already done so.

\subsection{Logging into the server}

Before you can use any CVS commands, you must log into the server. To do this,
use the CVS command "login":

\begin{example}
> cvs -d :pserver:user@aros.fh-konstanz.de:/home/AROS/CVS login
\end{example}

where \shell{user} is your login, eg. digulla:

\begin{example}
> cvs -d :pserver:digulla@aros.fh-konstanz.de:/home/AROS/CVS login
\end{example}

This should ask you for your password. Type it in and if there is no error
displayed, you are connected. If there is an error, try to omit the
":pserver:". If this still doesn't work, double check for
typos and if you really, really, really can't find anything, then you
got my email.

\begin{emph}
It seems that the protocol for CVS has changed. Version of CVS
upto 1.8.1 and earlier need not have ":pserver:" before the login name,
but later versions require it. If you have problems to login, try to omit
":pserver:" or prepend it. If CVS wants it, you will get an error reading
"cvs login: can only use pserver method with `login' command".
\end{emph}

If the login has succeeded, then you can save you some typing by storing
the argument to the \shell{-d} option in the environment
variable \shell{CVSROOT}. Use

\begin{example}
setenv CVSROOT :pserver:user@aros.fh-konstanz.de:/home/AROS/CVS
\end{example}

on Amiga or if you have a C shell (csh) and

\begin{example}
export CVSROOT=:pserver:user@aros.fh-konstanz.de:/home/AROS/CVS
\end{example}

for Bourne/Korn shells (bash, ksh).

On Amiga, you can make this
permanent by \shell{copy env:CVSROOT envarc:}, on Unix, you must add
this to the shell's startup file (\filename{.cshrc}, \filename{.profile},
\filename{.bashrc}, \filename{.tcshrc}, etc. Read the manual of your
shell to find out). If you don't know what kind of shell you have,
just try \shell{echo $SHELL} or \shell{echo $shell}. This should
print the name of your shell.

If you haven't set this variable, you must add \shell{-d ...}
right after cvs in the following examples.

Now you can use any CVS command to get a copy of all AROS sources, update
your sources or commit the changes you made.

\subsection{How to get a copy of all AROS sources}

Use the CVS checkout command for this:

\begin{example}
> cvs checkout AROS
\end{example}

This will create a
directory AROS and populate it with all sources.

\subsection{How to update the sources}

If you have some sources and just want to update them, you can use the
CVS update command. Change to the AROS directory and do this:

\begin{example}
> cvs update
\end{example}

This should merge any changes that other users have made into your
sources and create all new directories and files. If you
and someone else has changed the same file, then CVS will try to merge
the changes. That is, if he changed the first part and you the end of the
file, CVS will do all the work for you. If there are changes which CVS
can't resolve (eg. you said |x--;| and the other one |x=x-1;|), then
CVS will put \bold{both} versions in the file. Search for \shell{<<<<}
to find such problems.

You should do this before any commit in case this happens. So before
you commit, do an update, call \filename{make} if any changes were
made, fix the problems and then commit.

\subsection{Committing changes}

If you have changed a file, then you of course want to share your
work with the other guys. To do this, use the CVS commit command:

\begin{example}
> cvs commit
\end{example}

You can specify a list of files after the \shell{commit} or just do that in
the AROS directory to commit all changes. CVS will then ask you what you
did and send the changes to the CVS server for inclusion. Before you do
that, you should always make an update (see the previous section) to avoid
problems.

\subsection{Creating new files and directories}

You can also add new files or directories with the CVS add command:

\begin{example}
> cvs add file.c
\end{example}

or

\begin{example}
> cvs add dir
\end{example}

Note that \shell{cvs add dir/file} doesn't work. You can only add
files in the current directory.

\subsection{More infos about CVS}

Well, CVS has man pages and info files and here is a nice
\link{link}{http://www.loria.fr/~molli/cvs-index.html}.

\section{The jobserver}

\subsection{What is this ?}

Well, it's more a task server. Its purpose is to allow multiple people to
work at the same project at the same time without any two persons doing the
same work twice. This is accomplished by the jobserver. It has a database
with all tasks that are still to do, tasks that are currently under
construction and tasks which are finished.

\subsection{How does it work ?}

Just send an EMail to

\begin{example}
aros@aros.fh-konstanz.de
\end{example}

with the \shell{Subject: jobserv} and in the body of the mail

\begin{example}
help
\end{example}

It will list all commands that jobserv currently understands. Note that
this is an automated service so the subject must match. jobserv ignores all
lines in an email that it doesn't understand and stops reading at the first
\shell{end} or \shell{--} on a line of its own. jobserv will answer your EMails telling
you what it did, what commands it did understand, which it did execute and
which not and if not, why not. jobserv will also remember your EMail so
others can see who added/requested/did which job - So don't worry you won't
be credited for your work.

\subsection{Some commands the jobserver understands}

\begin{description}
\item{add <id> <description>} Add a new job with the id <id> and the short text
	    <description> as an explanation. <id> may contain any character
	    except whitespace. Here is an example:

\begin{example}
add exec00001 Write AddHead
\end{example}

	    If the command was successful, the reply will tell you that a
	    new job has been added to the database. If it wasn't
	    successful, it will tell you why not (eg. because there is
	    already a job with the same id).

\item{req <id>} Allocate a task. This task will now be allocated by you. Your
	    EMail will be stored with it so everyone can see who is working
	    on that job and query you if you take too long or whatever.

\item{done <id>} After you requested the job and finished it, you must tell
	    jobserv that you're through.

\item{show [free] [work] [done] [byme]} The most important command. It tells
	    jobserv that you want to know what jobs are available and the
	    like. All parameters are optional. "byme" is a flag which
	    restricts the answer to jobs which match your EMail. The other
	    flags are additive and restrict the reply to jobs which are
	    still open, currently in progress or finished. So to see
	    the jobs which were added and finished by you, use

\begin{example}
show free done byme
\end{example}

	    Note that jobserv doesn't remember that you added a task if
	    someone else allocated it. The most useful variants will be:

\begin{example}
show free
\end{example}

	    which shows everything that's still open and

\begin{example}
show work byme
\end{example}

	    which shows what jobs you did allocate and haven't finished
	    yet.
\end{description}

\section{Things that don't come with the AROS distribution}

Yeah, there are some things which are not in this archive for this or
that reason. Here we go:

\begin{enumeration}
\item The Amiga system header files are missing for obvious copyright
reasons. You can use the files which come with your C-Compiler
(DICE, SAS/C, StormC++ or Maxxon C++) or the ones from the Amiga
Developer CD 1.1 (that's what I did).

The Developer CD is available at

\begin{example}
Stefan Ossowskis Schatztruhe
Gesellschaft für Software mbH
Veronikastr. 33
45131 Essen
Germany

Order Phone: ++49-(0)2 01-78 8778

Fax: ++49-(0)2 01 - 79 84 47
EMail: stefano@tchest.e.eunet.de
WWW: \link{http://www.schatztruhe.de/}{http://www.schatztruhe.de/}
Support-Mailbox: ++49-(0)2 08-20 25 09
\end{example}

for DM 25.- (about $15) plus P&P. The CD contains all includes you need
and furthermore you can find valuable information on it like: The autodocs,
the examples for the various developer disk sets and the Rom Kernel Reference
Manuals (RKRMs), several tools to help to develop code and more. At the
price, it's a bargain.

\item Linux 2.0 for Intel CPUs (1.2.13 might work, but I haven't tried and
won't do it).

\item GNU make 3.74 or better - A real make is neccessary and this is
one (use "make --version" to find out which you have).

\item GCC 2.7.0 or better (2.7.2 is recommended because of the magnitude
of bugs fixed) (use "gcc --version" to find out which you have).

\item GAS/as from binutils 2.7 or better.

\item GDB, the GNU debugger. It is no great help in our project because we do
nasty things with the stack, but better than nothing anyway.

\item GAWK to generate a couple of files (I have 3.0.0, but any version should
work).

\end{enumeration}

\section{Things that are included in the AROS distribution}

There are a couple of files and directories below AROS and here is
a short overview of what they are and what you can do with them.

\begin{description}
\item{README*} Numerous READMEs which explain different aspects of AROS.
	The information is currently beeing moved from the README's to the
	docs.

\item{arosshell.c} The main code for the shell which allows you to execute AROS
	commands as you are used to it on your beloved Amiga. Also a very
	small demo of how it works and also probably the smallest demo
	that does something useful.

\item{crypt.c} This is a small program which allows you to create a password if
	you want to use the CVS server (prefered). See the section about
	\lref{CVS}{CVS} for how it works.

\item{tpl.c} Template file for AROS system library functions. Each function
	gets it's own file.

\item{makefile} This is the magic file which holds the whole thing together.
	It has the following rules:

	\begin{description}
	\item{clean} Delete all generated files.

	\item{all} This is the default rule: Check (almost) all dependencies
		and generate (almost) all files.

	\item{includes} Generate/update some AROS include files, mostly
		files in \filename{AROS/include/clib/}.

	\item{dist} Generate \filename{.tar.gz} and \filename{.lha}
		archives. They are put into \filename{AROS/dist/}. Make
		sure you have set the version in \filename{AROS/config/make.cfg}
		beforehand.

	\end{description}

\item{config/host.cfg} This is read by the Makefile to get the name of your
	C compiler, options that should be used and more. If this file is
	missing, make will generate it for you.

\item{config/i386-emul/} Linux version of the kernel. It consists mainly of
	a bunch of assembler files which implement functions that can't be
	done in C (eg. semaphores, stack handling or task switching). Note
	that this is the only directory which may contain assembler files
	and which is different for every architecture. If you begin your
	work on some new architecture, make such a directory for your
	hardware and put all hardware dependent files in there. It is a
	rule that you can do anything inside this directory as long as it
	has no influence on the other files and directories. The directory
	must support the standard rules \shell{all} and \shell{clean} and
	read \filename{AROS/config/make.cfg}. All files generated by the
	makefile should go into \filename{$(OSGENDIR)}.

	Some files in here might be of interest:

	\begin{description}
	\item{init.c} This file contains the real main() and sets up all
		libraries, devices and all other stuff which must be
		known before the first user process can begin to work.

	\item{machine.h} Constants which allow Exec to adjust to the local
		hardware.

	\item {makefile} This is a good example of how sub-makefiles for
		AROS should look like.

	\end{description}

\item{config/make.cfg} Global settings for the Makefiles. Each makefile reads this file
	before it does anything else (well, almost... most makefiles set a
	path to this file first :-) ) It sets up some interesting paths:

	\begin{description}
	\item{$(OSGENDIR)} Use this path for all files which should go into
		the OS itself.
	\end{description}

\item{config/m68k-emul/} Untested assembler code for machines which have an
	680x0 CPU but which are not Amigas (Mac, for example).

\item{config/m68k-native/} Assembler code for Amiga hardwares.

\item{configure} This is a small script which examines your system and
	creates a file named \filename{AROS/config/host.cfg} which is used by
	the makefiles.

\item{purify} A small script which can be put in front of the C compiler
	like this:

\begin{example}
purify cc ...
\end{example}

	It will modify some options to purify the code.

\item{bin/} This directory contains all generated files under the name of your
	OS (eg. \filename{AROS/bin/linux/}). This directory is called
	\shell{$(ARCHDIR)}. Below this are two more directories:
	\shell{$(BINDIR)} where the files should be put which the end user
	should see and \shell{$(GENDIR)} where you can create a directory
	to put all files one part of AROS needs (eg. \filename{libs/} or
	\filename{os/}). The directory \shell{$(OSGENDIR)} is below
	\shell{$(GENDIR)} and all \filename{*.o} files in this directory
	are collected to the \filename{AmigaOS.lib}.

\item{c/} This directory contains a couple of applications for AROS and some
	demos.

\item{alib/} contains the source for the \filename{amiga.lib}.

\item{amiga/} This is the directory where you can (and should) put things which
	are copyrighted by someone and thus now part of the archive; right
	now this means only the amiga header files which you get along with
	your C-Compiler (eg. DICE, SAS/C, StormC++, Maxon C++) or from the
	Amiga Developer CD 1.1 (recommended since it's the most simple and
	inexpensive way to get them). The CD is available at your local
	dealer or by mail order. Just put the includes into a subdir
	\filename{include/} below this directory and AROS will find them
	there.

\item{aros/} contains code for the \filename{aros.lib}; this library
	contains several function which make your life easier.

\item{devs/} System devices: \filename{console.device}

\item{dist/} \shell{make dist} will put an archive with all files for
	developers and users in this directory. Make sure the version in
	make.cfg is set to the correct value because it will be used to
	determine the name of the archive.

\item{dos/} \label{dos}The first library which is added to the OS by standard operations.
	Use this one as a starting point if you want to develop own
	libraries. Here is a list of interesting files:

	\begin{description}
	\item{dos_functable.c} An array with all functions of the library.
		It is generated by a script from the headers of all
		\filename{*.c}-files in this directory.

	\item{dos_init.c} The init-code (|lib_init()|, |lib_open()|,
		|lib_close()|, |lib_expunge()|).

	\item{dos_intern.h} A common include-file for all
		\filename{*.c}-files in this directory. It must not contain
		anything which is necessary outside this directory.

	\item{dos_debug.h} Enable and disable debugging for a function of
		the library.

	\item{makefile} This is a good example of how a makefile for a
		library, which is linked into the system, should look like
	\end{description}

	All other files are functions of the library with one function
	per file. Each file contains an AutoDoc-like header and some
	extra infos which are needed by the scripts. If possible each
	file should also contain a test which can be enabled with
	\shell{-DTEST}. See \filename{AROS/dos/filepart.c} for a good example.

\item{exec/} The source for the exec.library. This is no good starting point
	for own libraries since Exec is not initialized like other
	libraries and so some things are handled differently here.

	Exec relies on some files which are in \filename{$(KERNEL)/}.

\item{filesys/} A starting filesystem which uses the Linux ext2fs to emulate
	a DOS device, the basics for a \filename{NULL:} device and the
	beginnings of a RAM Disk.

\item{graphics/} Sourcecode for the \filename{graphics.library}. See
	\lref{dos/}{dos} for more information.

\item{include/} This directory contains all AROS specific includes as well as all
	Amiga includes which have been modified for AROS. Note that these
	files are searched *before* the files in \filename{amiga/include/}.
	Most people will notice this when they compile some program which
	uses a function which has not yet been implemented in AROS. The
	compiler will complain about a function without a prototype despite
	the fact that it is in \filename{amiga/include/clib/*_protos.h}.
	That's because it doesn't look there and if you ever get an error
	like this, have a look into include first.

\item{intuition/} Sourcecode for the \filename{intuition.library}. See
	\lref{dos/}{dos} for more information.

\item{test/} Testcode which is more complex.

\item{utility/} Sourcecode for the \filename{utility.library}. See
	\lref{dos/}{dos} for more information.

\end{description}

\section{Coding conventions}

\subsection{General style}

This code is used by many people and therefore you should keep some things
in mind when you submit source code:

\begin{itemize}
\item Keep things simple
\item Keep the source clean
\item Always know what you are doing
\item Tell what you are doing
\end{itemize}

\subsection{Comments}

AROS uses some of the comments in the source to generate the documentation.
Therefore it's neccessary to keep a certain format so the tools can find
their information. Other comments are ignored but they should explain what
you thought when you wrote the code. If you really can't think of an
explanation, then don't write the code a second time like this:

\begin{example}
/* This adds 1 to t */
t ++;
\end{example}

What we think of is this:

\begin{example}
/* Go on with next element */
t ++;
\end{example}

\subsection{Function prototypes and headers}

Every function in AROS must have a full ANSI C prototype. Prototypes should
be collected in in one header per file if it is needed by only a few files
(no need to recompile the whole project if you change a function which used
only once), in one header per directory if it's a commonly used function in
that directory or in one header per logical group (ie. one header for all
functions in a library).

The function header (ie. the comment before the function) must be of a
special format because the AutoDocs are generated from it. Here is an
example for it (from \filename{AROS/exec/addhead.c}):

\begin{example}
/*****************************************************************************

    NAME */
#include <exec/lists.h>
#include <clib/exec_protos.h>

	AROS_LH2I(void, AddHead,

/*  SYNOPSIS */
	AROS_LHA(struct List *, list, A0),
	AROS_LHA(struct Node *, node, A1),

/*  LOCATION */
	struct ExecBase *, SysBase, 40, Exec)

/*  FUNCTION
	Insert Node node as the first node of the list.

    INPUTS
	list - The list to insert the node into
	node - This node is to be inserted

    RESULT
	None.

    NOTES

    EXAMPLE
	struct List * list;
	struct Node * pred;

	// Insert Node at top
	AddHead (list, node);

    BUGS

    SEE ALSO
	NewList(), AddTail(), Insert(), Remove(), RemHead(), RemTail(),
	Enqueue()

    INTERNALS

    HISTORY
	26-08-95    digulla created after EXEC-Routine
	26-10-95    digulla adjusted to new calling scheme

******************************************************************************/
{
\end{example}

As you can see, comments are used to merge the function prototype and the
header into one.

\begin{description}
\item{NAME} This field contains all neccessary prototypes to use the function
from the user point of view and the name of the function in a |AROS_LH*()|
macro (Library Header). These macros are used to make the same code work on
different kind of hardwares. The name of the macro depends on the amount of
parameters and whether the function needs the library base. |AddHead()|
does not and therefore an "I" is appended to the macros name. If it need
the library base (like |AddTask()|), then the "I" is omitted.

If the function is not part of a shared library and it's arguments must be
passed in certain registers (eg. callback hooks), you must use
|AROS_UFH*()| macros (User Function Header) instead of |AROS_LH*()|. Append
the number of arguments to this macro. Since it has never a base, the field
LOCATION must be omitted and it's not neccessary to append the "I" to the
macros name. An example for a callback hook |foo()| would be:

\begin{example}
AROS_UFH3(ULONG, foo,
    AROS_UFHA(struct Hook, hook,  A0),
    AROS_UFHA(APTR,        obj,   A2),
    AROS_UFHA(APTR,        param, A1)
)
\end{example}

(note that the registers need not have a particular order).

If the function is not part of a shared library and it's arguments need not
be in specific registers, you need no |AROS_*H*()| macros:

\begin{example}
/*****************************************************************************

    NAME */
#include <header.h>

	int foo (

/*  SYNOPSIS */
	int a,
	int b)

/*  FUNCTION
	blahblahblah.
	...

*****************************************************************************/
\end{example}

\item{SYNOPSIS} This field contains all arguments of the function one by
one in |AROS_LHA()| macros (Library Header Argument). This macro makes sure
the respective argument is put in the right CPU register when the function
is called (if possible and neccessary). The first argument for the macro is
the type of the parameter followed by the name of the parameter and the
register the parameter is expected in. Valid names for registers are D0,
D1, D2 upto D7 and A0 upto A6.

If the function is not part of a library but the arguments must be passed
to it in registers, then use |AROS_UFHA()| macros (User Function Header
Argument) which take the same parameters as the |AROS_LHA()| macros. Don't
forget the closing parenthese for the AROS_UFC

If the function is not part of a library and the arguments need not be
passed in registers, no macros are neccessary.

\item{LOCATION} This field is neccessary for shared libraries only. It
contains the last four parameters for the |AROS_LH*()| macro which are the
type of the library, the name of the variable, in which the function
expects the library base, the offset of the function in the jumptable (the
first vector has 1 and the first vector which may be used by a function is
5) and the name of the library.

\item{FUNCTION} This field contains a description of the function.

\item{INPUTS} This field contains a list of all parameters of the form
"name - description" or "name, name, name - description". The description
should tell what the parameter is and what values can be passed to it.
There is no point in explaining the parameter twice in FUNCTION and here.
If the function has no parameters, say "None." here.

\item{RESULT} What the function passes back. This includes return values
and values passed in arguments of the function. If the function may fail,
you should explain what it returns on failure and why it might fail.

\item{NOTES} Important things the user must know or take into account.

\item{EXAMPLE} This field should contain a small or fully featured example.
A good way to present an example is to write some code which tests the
function, put it into |#ifdef TEST| somewhere in the file and put a
"See below." here. If you need comments in the code, you have two ways for
this. If you need only short one-line comments, use C++ style (|//
comment|). Everything from the |//| to the end if the line is the comment.
If you need more comment, then you can end the comment after the |EXAMPLE|
and use |#ifdef EXAMPLE| to mask the example out:

\begin{example}
    EXAMPLE */
#ifdef EXAMPLE
	struct List * list;
	struct Node * pred;

	/* Insert Node at top of the list */
	AddHead (list, node);
#endif
\end{example}

Don't use |#ifdef EXAMPLE| if you have a fully featured example (ie. one
which can be compiled without errors).

\item{BUGS} This field contains a list of known bugs.

\item{SEE ALSO} This field contains a list of other functions and documents
which might be of interest. This includes function which you need to
initialize, create or destroy an object necessary for this function,
functions which do similar and opposite things on the main object.

For example, |SetAttrs()| should contain functions here which can create,
destroy and manipulate BOOPSI objects but not taglists.

\item{INTERNALS} This field should contain information for other developers
which are irrelevant to the user, for example an explanation of the
algorithm of the function or dependencies.

\item{HISTORY} This field should contain a brief history of changes.
The format is date (DD-MM-YY), acronym (one word) and description.

\end{description}

\subsection{Formatting}

Here is an example of how to format AROS code:

\begin{example}
{
    /* a */
    struct RastPort * rp;
    int 	      a;

    /* b */
    rp = NULL;
    a  = 1;

    /* c */
    if (a == 1)
	printf ("Init worked\\n");

    /* d */
    if
    (
	!(rp = Get_a_pointer_to_the_RastPort
	    (
		some,
		long,
		arguments
	    )
	)
    ||
	a == 0
    )
    {
	printf ("Something failed\\n");
	return FAIL;
    }

    /* e */
    a = printf ("My RastPort is %p, a=%d\\n"
	, rp
	, a
    );

    return OK;
}
\end{example}

Look ugly, eh ? :-)

Ok, here are the rules:

\begin{itemize}
\item If several lines contain similar code, put similar things below each
other (see a and b);

\item Put spaces between operands and operators

\item Put braces {}, brackets [] and parenthese () below each other (d) if
there is much code between. Brackets and parenthese may be in one line if
the code between is small (c)

\item Indent by 4 Spaces. Two indent levels may be abbreviated by one tab.

\item If you have a function with many arguments (d, e) you should put the
parenthese in lines of their own and each argument in one line (d) or put
the first argument behind the opening parenthese (e) and each following
argument in a line of its own with the comma in front. The closing
parenthese is in a line of its own and aligned with the beginning of the
expression (ie. the a and not the opening parenthese or the |printf()|).

\item use a single blank line to separate logical blocks. Large comments
should have a blank line before and after them, small comments should be
put before the code they explain with only one blank line before them.

\end{itemize}


