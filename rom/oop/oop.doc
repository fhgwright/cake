Overview:
This document tries to explain the choices that
are made in deciding the design of the new OOP
system, which will be used fo (among other things)
the HIDDs.

General design goals:

The system should..

1) have fast method invocation. Especially when calling the same method
on the same objetc many times. (Eg. GetPixel()/SetPixel())


2) allow non-centralized allocation of IDs. This means that there is no
agency somewhere in the world where you have to allocate an ID. IDs
are allocated at runtime.


3) be location transparent. Ie. you invoke a
method the same way as for a local objet, even if
the object is owned by another task, or is
located on a different machine.

4) support transparent object migration.


Possible solutions to design goals w/pros & cons

1) Invocation speed.
-------------------
For having ultimately fast method invocation we supply method objects.

For normal method invocation there are generally two approaches:

I) Hashing single methods.
II) Hashing interfaces, where an interface
is an array of methods (kinda like a AmigaOS library
jump table.)

I) is a bit faster than II)

In order to avoid having to hash the methods, all methods of a class
are in a single table. This includes the methods of all parent classes
so these can also be called directly (no need for DoSuperMethod()
in the dispatcher).

For this to work, we need:

- A method string -> ID to convert the method name to the method ID

- When you allocate a new class, you must allocate a table (size =
parentClass->numMethods + self->numMethods), copy the parent method
table and overwrite/add the own methods to the table

- The user uses a global variable in the classbase as the basic offset
to call methods of this class. The header file defines the offsets.

Interfaces work as usual but they store maybe only the real methodID
(one lookup more and one method object less).

Caveats:

- When a parent class changes its method table, then the child classes
won't notice. This could be avoided it we copy method objects.

- the DoMethod() stub must do an add for each method invokation but
no hashing.

Interfaces can be implemented like this:

- One hash table which contains tables of methods/method IDs and the
key is the interface ID.

- One hash table which contains method objects and the key is the
computed interface+method ID.

2) Noncentralized ID allocation.
-------------------------------
To allow for this, we avoid fixed integer
IDs (like in BOOPSI).
Instead we use global variables for
IDs.

Two ways to allocate IDs:

I)
Store interface IDs in global vars, and generate method IDs on the fly as
sum of interface ID and a offset ID for the method.

Example:

extern ULONG __OOPI_Root;

#define I_Root	__OOPI_Root
#define MIDX_Root_New		0
#define MIDX_Root_Dispose	1

#define M_Root_New	(I_Root + MIDX_Root_New)
#define M_Root_Dispose	(I_Root + MIDX_Root_Dispose)

Pro:
- Uses little mem.
- Relatively little CPU time used for initialization.

Con:
- uses more CPU time for initialization.

II)
Use one global var for each methodID.

Pro:
- Faster pr. call.
- Leaves more flexibility for future changes.
- Allows to specify each method as a string
in MakeClass().

Con:
- Uses more mem.
- Very hard to initialize


As for AttrIDs, there is a problem with using II), because then one can't
use switch() to parse AttrIDs.

Solution: Use methods for set & get of each attribute. which will use some
mem. Con: Clumsy.

To avoid the problems with init, we can use a global ClassBase (like a
library base) and use a public field in there to store the offsets. As for
attributes, a class should allocate a fixed number of IDs for its
attributes and store the base in the ClassBase. The header file then
contains offsets for each Attribute. In the class, you can very quickly
check if an attribute is part of the class:

    ULONG id = tag->ti_Tag - class->cl_attrBase;

    if (id < class->cl_numAttrs)
	... handle own attributes
    else
	... handle attributes of other classes

3) + 4)

To allow these two, we use method objects. Method objects
contain the following attributes:

- A pointer to the method
- The method ID
- The class
- The object
- If several objects are created for the same method and the
method, for which they were created, changes, then all other
method objects change as well.
- The Method class contains a DoMethod() which is used to
call the method stored in the object.

By overloading DoMethod() of the Method class, you can implement
thread safe objects, migrate objects to other computers, etc.
