#!/bin/sh
# Start tclsh with options \
exec tclsh8.0 "$0" "$@"

set optionfile "$env(HOME)/.mmake.opts"

set project "default"
set defaultproject "default"

set optfh [open $optionfile r]

proc getvar {prj var} {
    global vars

    if {[array names vars $prj,$var] == ""} {
	return "\$($var)"
    }

    return "$vars($prj,$var)"
}

proc substvars {prj str} {
    set result ""

    while {$str != ""} {
	if {[regexp {([^$]*)\$[(]([^)]+)[)](.*)} $str x pre var str]} {
	    set result "$result$pre[getvar $prj $var]"
	} else {
	    set result "$result$str"
	    set str ""
	}
    }

    return "$result"
}

proc getargs {project line} {
    set args {}

    while {$line != ""} {
	regexp "\[ \t\]*(\"\[^\"\]*\"|\[^ \t\]*)\[ \t\]*(.*)" $line x arg line
	set arg [substvars $project $arg]
	lappend args "$arg"
    }

    return $args
}

proc initproject project {
    global opts

    set opts($project,defaultmakefilename)    Makefile
    set opts($project,top)                    [pwd]
    set opts($project,defaulttarget)          all
    set opts($project,genmakefilescript)      ""
    set opts($project,globalvariables)        ""

    # All makefiles of this project
    set opts($project,makefiles)              {}

    # Flag: Build list of makefiles ?
    set opts($project,buildmflist)            1
    # Flag: Read vars ?
    set opts($project,readvars)               1

    # All known metatargets. This is accompanied by several other lists:
    # tmf($p,$t) - The makefiles which contain this target
    # td($p,$t) - This is the targets $t depends on
    # tutd($p,$t) - 1 if the target is up-to-date
    set opts($project,targets)                {}
    set opts($project,buildtargetlist)        1
}

initproject $project

while {[gets $optfh line] >= 0} {
    if {[string match {\[*\]} $line]} {
	regsub {^.*\[} $line "" line
	regsub {\].*$} $line "" line
	set project $line

#puts "project=$project"

	if {$defaultproject == "default"} {
	    set defaultproject $project
	}

	initproject $project
	lappend projects $project
    } else {
	if {[regexp "(\[^ \t\]+)\[ \t\]+(.*)" $line x cmd args]} {
	    set cmd [string tolower $cmd]
#puts "cmd=$cmd args=\"$args\""

	    if {$cmd == "add"} {
		lappend opts($project,makefiles) $args
	    } else {
		set opts($project,$cmd) $args
	    }
	}
    }
}

set mflags {}
set targets {}

for {set t 0} {$t < $argc} {incr t} {
    #puts "$t: [lindex $argv $t]"
    set arg [lindex $argv $t]
    if {[string match "-*" $arg]} {
	lappend mflags $arg
    } else {
	lappend targets $arg
    }
}

if {[llength $targets] == 0} {
    lappend targets $defaultproject
}

proc buildmflist project {
    global opts

    if {!$opts($project,buildmflist)} return

    set opts($project,buildmflist) 0

    puts "Collecting makefiles..."

    set mfn $opts($project,defaultmakefilename)

    set top $opts($project,top)
    set len [expr [string length $top] + 1]

    set fh [open "|find \"$top\" -name \"$mfn\" -print" r]

    while {[gets $fh line] >= 0} {
	set mfn [string range $line $len end]

	if {[file exists $line.src]} {
	    lappend opts($project,makefiles) $mfn.src
	} else {
	    lappend opts($project,makefiles) $mfn
	}
    }

    set opts($project,makefiles) [lsort $opts($project,makefiles)]

    close $fh

    #puts "MF=$opts($project,makefiles)"
}

proc progress {max curr datavar} {
    upvar $datavar data

    set x [expr int($curr*10/$max)]

    if {$x != $data} {
	set data $x
	puts -nonewline "."
	flush stdout
    }
}

proc buildtargetlist project {
    global opts tmf td tutd

    if {!$opts($project,buildtargetlist)} return

    set opts($project,buildtargetlist) 0

    puts -nonewline "Collecting meta targets"
    flush stdout

    set max [llength $opts($project,makefiles)]
    set pos 0
    set data 0

    foreach mf $opts($project,makefiles) {
	incr pos
	progress $max $pos data

	set fh [open $mf r]

	while {[gets $fh line] >= 0} {
	    if {[string match "#MM*" $line]} {
		regsub "^#MM\[ \t\]*" $line "" line
		# If no targets are specified, the target in the next line
		# is read. The dependencies are ignored !
		if {$line == ""} {
		    gets $fh line
		    regsub ":" $line " " line
		    set args [getargs $project $line]
		    set target [lindex $args 0]
		    lappend opts($project,targets) $target
		    set tmf($project,$target) $mf
		    set td($project,$target) {}
		} else {
		    set tmp [split $line ":"]
		    set targets [getargs $project [lindex $tmp 0]]
		    set deps [getargs $project [lindex $tmp 1]]
#puts "target deps=$deps ([lindex $tmp 1])"

		    foreach target $targets {
			# Is this targets unknown yet ?
			if {[lsearch -exact $opts($project,targets) $target] == -1} {
			    lappend opts($project,targets) $target
			    set tmf($project,$target) $mf
			    set td($project,$target) $deps
			} else {
			    if {[lsearch $tmf($project,$target) $mf] == -1} {
				lappend tmf($project,$target) $mf
			    }

			    foreach dep $deps {
				if {[lsearch $td($project,$target) $dep] == -1} {
				    lappend td($project,$target) $dep
				}
			    }
			}
		    }
		}
	    }
	}

	foreach t $opts($project,targets) {
	    set tutd($project,$t) 0
	}

	close $fh
    }

    puts ""

    printarray td
    printarray tmf
}

proc printarray avar {
    upvar $avar a

    set alist [array get a]
    set len [llength $alist]
    set slist {}

    puts "Array $avar:"

    for {set t 0} {$t < $len} {incr t 2} {
	lappend slist [list [lindex $alist $t] [lindex $alist [expr $t+1]]]
    }

    set slist [lsort $slist]

    foreach item $slist {
	puts "    [lindex $item 0]=[lindex $item 1]"
    }
}

proc readvars prj {
    global opts vars

    if {!$opts($prj,readvars)} return

    set opts($prj,readvars) 0

    puts "Read vars..."

    set vars($prj,TOP) $opts($prj,top)
    set vars($prj,CURDIR) ""

    if {$opts($prj,globalvariables) != ""} {
	set fn [substvars $prj $opts($prj,globalvariables)]
	set fh [open $fn r]

	while {[gets $fh line] >= 0} {
	    if {![string match "#*" $line]} {
		regsub "\[ \t\]+" $line " " line
		regsub ":+=" $line "=" line
		set tmp [split $line "="]
		set var [lindex $tmp 0]
		set val [lindex $tmp 1]
		regsub "(^ | $)" $var "" var
		regsub "(^ | $)" $val "" val
		set vars($prj,$var) [substvars $prj $val]
	    }
	}

	close $fh
    }

    #printarray vars
}

proc execute {prj cmd in out args} {
    global errorCode

    set argstr [substvars $prj [join $args " "]]
    set cmd [substvars $prj $cmd]

    if {$in != "-"} {
	set in "<[substvars $prj $in]"
    } else {
	set in ""
    }
    if {$out != "-"} {
	set out ">[substvars $prj $out]"
    } else {
	set out ">@stdout"
    }

    #puts --nonewline "$in $out "
    puts "$cmd $argstr"

    if {1} {
	set error [catch "exec $in $out 2>@stderr $cmd $argstr" msg]
	if {$error != 0} {
	    puts "$msg"
	    return 0;
	}
    }

    return 1
}

proc callmake {prj targ mf} {
    global opts mflags vars

    set mf [substvars $prj $mf]

    set dir [file dirname $mf]
    set file [file tail $mf]
    set ext [file extension $mf]
#puts "dir=$dir file=$file ext=$ext"

    if {$ext == ".src"} {
	regsub "\.\[^.\]*$" $file "" file
#puts "dir=$dir file=$file ext=$ext"
	set src $mf
	set dest [file join $dir $file]

	if {![file exists $dest]
	    || [file mtime $src] > [file mtime $dest]
	    || ($opts($prj,genmakefiledeps) != ""
		&& [file mtime [substvars $prj $opts($prj,genmakefiledeps)]]
	    )
	} {
	    if {![execute $prj $opts($prj,genmakefilescript) - $dest $src]} {
		puts stderr "Error while regenerating makefile $dest"
		exit 10
	    }
	}
    }

    cd [file join $opts($prj,top) $dir]

    set vars($prj,CURDIR) $dir

    if {$file != "makefile"} {
	set mfopt "-f $file"
    } else {
	set mfopt ""
    }

    if {![execute $prj make - - $mflags $mfopt "TOP=$(TOP)" "CURDIR=$dir" $targ]} {
	puts stderr "Error while running make in $dir"
	exit 10
    }
}

proc maketarget target {
    global opts projects td tutd tmf

    set tmp [split $target .]

    set project [lindex $tmp 0]

    if {[lsearch -exact $projects $project] == -1} {
	puts "Nothing known about project $project"
	return
    }

    if {[llength $tmp] > 1} {
	set target [lindex $tmp 1]
    } else {
	set target $opts($project,defaulttarget)
    }

    puts "Building $project.$target"

    cd $opts($project,top)

    # Make sure no loops occur
    set tutd($project,$target) 1

    # Build lists
    buildmflist $project
    readvars $project
    buildtargetlist $project

    if {[array names td $project,$target] == ""} {
	puts "Nothing known about target $target in project $project"
	return
    }

    foreach subtarget $td($project,$target) {
	if {!$tutd($project,$subtarget)} {
	    maketarget $project.$subtarget
	}
    }

    foreach mf $tmf($project,$target) {
	callmake $project $target $mf
    }
}

puts "mflags=$mflags"
puts "targets=$targets"

#printarray opts

set currdir [pwd]

foreach target $targets {
    maketarget $target
}

cd $currdir
