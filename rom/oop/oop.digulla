
Example for a class which supports plain methods and interfaces.
The class is used as a building block in a filesystem like
database:

    - Objects are sorted hierarchical (ie. there is a path to an
      object like a/b/object)
    - Objects have similar attributes as files (ie. a name, a
      size, a creation date and access flags).

#defile LISTITEMINTERFACE   "listitem.interface"

// Namespaces would be great *sigh*
enum ListItemMethods
{
    _LIM_AddNotify,
    _LIM_RemNotify,
    _LIM_CheckAccess,
    _LIM_Last
};

enum ListItemAttrs
{
    _LIA_Name,
    _LIA_Size,
    _LIA_Date,
};

struct LIMsg_AddNotify
{
    ULONG		methodID;
    NotificationHandler handler;
};

struct LIMsg_RemNotify
{
    ULONG		methodID;
    NotificationHandler handler;
};

struct LIMsg_CheckAccess
{
    ULONG methodID;
    User  user;
    Group group;
    ULONG accessInfo; // Read, Write, Create, etc.
};



#define FILECLASS   "file.class"

enum FileClassMethods
{
    _FM_LIM_Base,

    _FM_Read = _FM_LIM_Base + _LIM_Last,
    _FM_Write,
    _FM_Seek,
    _FM_Tell,

    _FM_Last;
};




The class base for FILECLASS looks like this:

Class FileClass =
{
    Class parent;

    Method * methodTable =
    {
	// Methods of the ListItem interface
	FM_AddNotify,
	FM_RemNotify,

	// Methods of the File class
	FM_Read,
	FM_Write,
	FM_Seek,
	FM_Tell,
    };

    ULONG methodBase = AllocMethodIDs (&FileClass, _FM_Last);
    // == FileClass->parent->methodBase + FileClass->parent->methodCount

    ULONG methodCount = FCM_Last;

    Hashtable interfaces;

    // No special doMethod() in this class
    Method doMethod = parent->doMethod;

    // How to invoke an interface
    Method doIfMethod = parent->doIfMethod;

    // I have own for these
    Method new = FM_New;
    Method delete = FM_Delete;
    Method setAttrs = FM_SetAttrs;
    Method getAttr = FM_GetAttr;
};


// Create class

// Base ID of an interface
ULONG listItemInterfaceID = GetInterfaceID (LISTITEMINTERFACE)

Hashtable_Add (FileClass->interfaces, listItemInterfaceID + _LIM_AddNotify,
    FM_AddNotify);
Hashtable_Add (FileClass->interfaces, listItemInterfaceID + _LIM_RemNotify,
    FM_RemNotify);



// DoMethod stub:

IPTR DoMethod (Class cl, Object o, Msg m)
{
    return cl->doMethod (cl, o, m);
}

// DoIMethod stub:

IPTR DoIfMethod (Class cl, Object o, Msg m)
{

    return cl->doIfMethod (cl, o, m);
}

// parent->doMethod:

IPTR xxx_DoMethod (Class cl, Object o, Msg m)
{
    return cl->methodTable[m->MethodID - cl->methodBase] (cl, o, m);
}

// parent->doIfMethod:

IPTR xxx_DoIfMethod (Class cl, Object o, Msg m)
{
    // m->methodID contains an interface method
    mID = Hashtable_Find (cl->interfaces, m->methodID);

    // Note that m->methodID contains the "wrong" ID.
    return cl->methodTable[mID] (cl, o, m);
}




// --- Stubs

/* If a class never needs to do any magic in DoMethod(), it can
use the direct call (ie.

    return cl->methodTable[ID] (...) in the stub.

ID is the constant from the header file. */

// Normal invokation of an interface
void ListItem_AddNotify (Object o, NotificationHandler handler)
{
    ULONG listItemInterfaceID = GetInterfaceID (LISTITEMINTERFACE)
    struct LIMsg_AddNotify msg =
    {
	listItemInterfaceID + LIM_AddNotify,
	handler
    };
    OCLASS(o)->doIfMethod (OCLASS(o), o, &msg);
}


// Optimized invokation of a local function
ULONG File_Read (Object file, UBYTE * buffer, ULONG count)
{
    struct FMsg_Read msg =
    {
	OCLASS(file)->methodBase + _FM_Read,
	buffer,
	count
    };

    return OCLASS(file)->methodTable[_FM_Read] (OCLASS(file), file, &msg);
}


Pro: - Method invokation can be optimized without using method objects

Con: - Interface methods are handled unlike normal methods
     - Each stub of an interface must look up the base ID of the
       interface.
     - Interfaces can't be optimized

