Classes are objects of metaclasses, so therefore
classes are created with NewObjectA().

As of now there are two different metaclasses available:

IFMeta (ID:  CLID_IFMeta) and HIDDMeta (ID: CLID_HIDDMeta).

The difference between them is that the IFMeta
handles multiple interfaces, while the HIDDMeta doesn't,
but it gains quite some speed.
So IFMeta classes are more flexible, but HIDDMeta
classes are faster, and should be used for the HIDDs.

How to create a class is best shown through an example.
Here is a Timer class with two simple methods,
Start and Stop.
Note, this example doesn't show the New and Dispose
methods and DoSuperMethod() usage, but it is exactly the same as in BOOPSI,
so those familiar with BOOPSI,should find creating classes with this
system simple.


/* In the classes' include file you have to define class ID, interface ID
   method offsets and attribute offset
*/

/* The IDs below should really be genrated by some tool,
   as a combination of current time and some machine
   unique ID, IP address or othe unique entity, to
   assure unique IDs.

*/   

#define CLID_Timer	"timerclass"
#define IID_Time	"I_timer"


enum
{
    MO_Timer_Start	= 0,
    MO_Timer_Stop,
    
    NUM_M_Timer	/* number of methods in the Timer interface */
    
};


enum
{
    AO_Timer_Elapsed = 0,
    
    NUM_A_Timer	/* number of attrs in the timer interface */
};


/* instance data */
struct timer_data
{
    struct timeval start_time;
    struct timeval elapsed_time;
};

/* The methods */


static VOID timer_start(Class *cl, Object *o, Msg msg)
{
    struct timer_data *data;

    data = INST_DATA(tcl, o);

    gettimeofday(&(data->start_time), NULL);

    return;
}

static VOID timer_stop(Class *cl, Object *o, Msg msg)
{
    struct timer_data *data = INST_DATA(tcl, o);
    gettimeofday(&(data->elapsed_time), NULL);

    SubTime(&(data->elapsed_time), &(data->start_time));

    return;
}


#define NUM_TIMER_METHODS 2
Class *make_timerclass()
{

    struct MethodDescr methods[NUM_TIMER_METHODS + 1] =
    {
	{(IPTR (*)())timer_start,		MO_Timer_Start},
	{(IPTR (*)())timer_stop,		MO_Timer_Stop},
	{NULL, 0UL} /* must be null-terminated */

    };

    struct InterfaceDescr ifdescr[] =
    {
    	{ methods, "Timer", NUM_TIMER_METHODS },
	{ NULL, 0UL, 0UL} /* must be null-terminated */
    };

    struct TagItem tags[] =
    {
        {A_Meta_SuperID,		(IPTR)CLID_Root},
	{A_Meta_InterfaceDescr,		(IPTR)ifdescr},
	{A_Meta_ID,			(IPTR)CLID_Timer},
	{A_Meta_InstSize,		(IPTR)sizeof (struct timer_data)},
	{TAG_DONE, 0UL}
    };
    
    Class *tcl;

    
    /* Make it a class of the HIDDMeta */
    tcl = (Class *)NewObjectA(NULL, CLID_HIDDMeta, tags);


    if (tcl)
    {
    	/* Make the class public */
    	AddClass(tcl);
    }

    return (tcl);
}

VOID free_timerclass(Class *cl)
{
    DisposeObject((Object *)cl);

    return;
}


/* Stubs would look like this */

VOID Timer_Start(Object *timer)
{
    static ULONG mid = NULL;
    
    if (!mid)
    {
    	/* First time executed the stub converts the full method ID
	   (String Interface ID, numeric method offset) into a
	   numeric method ID.
	*/
	
    	mid = GetMethodID(IID_Timer, MO_Timer_Start);
    }

    DoMethod(timer, (Msg)&mid);
    
    return;	
}


This API is bound to change, as its not flexible enough
(not future-proof), better use tags for specifying all info.

Anyway, have a look at the unixio.hidd and hiddclass implementation
for a bit more complex usage of this system.
