vbcc - C compiler (c) in 1995-97 by Volker Barthelmann


INTRODUCTION

    vbcc is a free portable and retargetable ANSI C compiler.
    It is clearly split into a target independant and a target dependant
    part and supports emulating datatypes of the target machine on any
    other machine so that it is possible to e.g. make a crosscompiler for
    a 64bit machine on a 32bit machine.
    This document only deals with the target dependant parts of the
    DEC Alpha version.

    This is a pre-alpha version!


LEGAL

    vbcc is (c) in 1995-97 by Volker Barthelmann. All code is written by me
    and may be freely redistributed as long as no modifications are made
    and nothing is charged for it.
    Non-commercial usage of vbcc is allowed without any restrictions.
    Commercial usage needs my written consent.

    Sending me money, gifts, postcards etc. would of course be very nice
    and may encourage further development of vbcc, but is not legally or
    morally necessary to use vbcc.


ADDITIONAL OPTIONS FOR THIS VERSION

    -merge-constants

                Place identical floating point constants at the same
                memory location. This can reduce program size and increase
                compilation time.

    -const-in-data

                By default constant data will be placed in the code
                section (and therefore is accessable with faster pc-relative
                addressing modes). Using this option it will be placed in the
                data section.
                Note that on operating systems with memory protection this
                option will disable write-protection of constant data.

    -no-builtins

                Do not replace certain builtin functions by inline code.
                This may be useful if you use this code generator with
                another frontend than vbcc.
                stdarg.h will not work with -no-builtins.


SOME INTERNALS

    The current version generates assembly output for use with the GNU
    assembler. The generated code should work on systems with 21064,
    21066, 21164 and higher Alpha CPUs.

    The register names are:

        $0 through $31 for the general purpose registers and
        $f0 through $f31 for the floating point registers

    The registers $0-$8, $16-$28, $f0, $f1 and $f10-$f30
    are used as scratch registers (i.e. they can be destroyed in function
    calls), all other registers are preserved. Of course $31 and $f31
    cannot be used.

    The first 6 function arguments which have arithmetic or pointer types
    are passed in registers $16/$f16 through $21/$f21.

    Integers and pointers are returned in $0, floats and doubles in $f0.
    All other types are returned by passing the function the address
    of the result as a hidden argument - so when you call such a function
    without a proper declaration in scope you can expect a crash.

    The elementary data types are represented like:

    type        size in bits        alignment in bytes

    char                8                       1
    short              16                       2
    int                32                       4
    long               64                       8
    all pointers       64                       8
    float              32                       4
    double             64                       8


STDARG

    A possible <stdarg.h> could look like this:

    typedef struct {
      char *regbase;
      char *membase;
      int arg;
    } va_list;

    char *__va_start(void);
    int __va_fixargs(void);

    #define va_start(vl,dummy) \
    (vl.arg=__va_fixargs(),vl.regbase=__va_start(),vl.membase=vl.regbase+(6-vl.arg)*16)

    #define va_end(vl) (vl.regbase=vl.membase=0)

    #define __va_size(type) ((sizeof(type)+7)/8*8)
    #define va_arg(vl,type) \
     ( \
      ((__typeof(type)&15)<=8&&++vl.arg<=6) ? \
       ( \
        ((__typeof(type)&15)==5||(__typeof(type)&15)==6) ? \
          (vl.regbase+=16,*(type *)(vl.regbase-8)) \
        : \
          (vl.regbase+=16,*(type *)(vl.regbase-16)) \
       ) \
      : \
       (vl.membase+=__va_size(type),*(type *)(vl.membase-__va_size(type))) \
     )


KNOWN PROBLEMS

    - generated code is not very good
    - nested function calls which pass parameters on the stack will not work
    - several other problems


Volker Barthelmann                                      volker@vb.franken.de
Kennedy-Ring 39
91301 Forchheim
Germany

