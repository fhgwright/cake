\begin{new}{6.8.1997}
\chapter{Hardware Independend Device Driver - HIDD}

\section{Introduction}

\bold{This is a *preliminary* document. It's neither complete nor
correct. It's purpose is to offer a basis for discussion not to put
things into concrete}

The AmigaOS is built on the Amigas' custom chips. This is a fact which is
eventually discovered when you hit the rather tight limits they impose
and try to circumvent them by adding new hardware. For the new hardware,
you also need a device driver. But sometimes, the applications can't be
made to use this new driver because the old one is compiled in or, even
worse, the OS refuses to use anything besides the built in driver or,
even more worse, the OS doesn't use a driver to access this chip at all.

AROS was designed to be a portable OS and be compatible to the old AmigaOS.
But we had to design something which lessens these burdens without
becoming incompatible nor loosing too much speed. So we developed the
idea of the HIDD - the Hardware Independend Device Driver.

\section{Features}

HIDDs offer a consistent API for everything one could want to do with
a device. Here is a quick overview:

\begin{itemize}
\item Query the system for all available HIDDs or only for certain types
(eg. all serial HIDDs or all graphics HIDDs).
\item Configure a HIDD
\item Use a HIDD
\end{itemize}

The complete life cycle of a HIDD is like this:

\begin{enumeration}
\item The OS boots. HIDDs on external cards and in the ROM get installed by
the OS in the global list of all available HIDDs. Also the OS searches for
HIDDs installed on the harddisk.

\item The OS reads the extended romtags from all HIDDs and puts that
information in the global list of all available HIDDs.

\item Some application asks for a list with the informations about
all HIDDs or a specific type of HIDD.

\item The application loads the HIDD and the config plugin. This makes the
HIDD initialize some internal data structures but not always the hardware
because a HIDD might be the driver for several kinds of different hardwares
which are all available. Thus it must be configured first.

\item The application asks for the current config of the HIDD. If the
config plugin has its own GUI, the application displays it. Otherwise,
the application displays the information in an own window. For this,
the application queries the config plugin for all available modes.

\item The app reads the config from the config plugin, then reads the list
of available modes for this config (ie. what can be changed in the current
config) and displays this. Then the user can select some mode, the app
changes the config and starts over.

\item When the user presses ok, the application or config plugin closes
the window/GUI. The Ok or Apply button must be ghosted as long as
the HIDD says that the configuration is not ok. The application can
now expunge the config plugin. If a HIDD supports saving its config,
it must do so.

\item When the device is explicitly activated or used for the first time
(eg. data is written to it), it will use the configuration to initialize
the hardware.

\item The user can deactivate the device and change the config if the
HIDD permits that.

\end{enumeration}

\section{The HIDD Support API}

\begin{code}
/* Get a list with pointers to HIDD devices */
ULONG HIDD_FindHIDD (struct TagItem *, Class ** hiddArray);
\end{code}

You can then use the HIDD API to query the devices for their infos. Use
|FreeVec()| to dispose the array. |HIDDV_FindHIDD_All| as type gives
the complete list of all known HIDDs.

\section{The HIDD API}

HIDDs are BOOPSI objects which support the Exec Device API.

\begin{methods}
\item{LONG OM_SET (struct TagItem * AttrList)}
Change some attributes of a HIDD.

The return code is 0 in case of success or != 0 in case of an error.
If the return code is > 0, then it's the number of the offending tag in the
list, if it's < 0, then it's an error code.
You can use |HIDDM_ValueToString()| with the special tag |HIDDA_ErrorCode|
to convert this error code into a string.

\item{LONG OM_GET (Tag AttrID, IPTR * Storage)} Query a single attribute
from the HIDD in general (eg. its name and version) and the current status.
You can only query attributes which are gettable.

The return code is 0 in case of success or < 0 in case of an error.
You can use |HIDDM_ValueToString()| with the special tag |HIDDA_ErrorCode|
to convert the error code into a string.

\item{LONG OM_MGET (struct TagItem * AttrList)} Query one or more attributes
from the HIDD in general (eg. its name and version) and the current status.
You can only query attributes which are gettable. The |ti_Data| fields of
|AttrList| must be pointers of the type which is expected for the
respective attribute.

The return code is 0 in case of success or != 0 in case of an error.
If the return code is > 0, then it's the number of the offending tag in the
list, if it's < 0, then it's an error code.
You can use |HIDDM_ValueToString()| with the special tag |HIDDA_ErrorCode|
to convert this error code into a string.

\item{LONG HIDDM_BeginIO (struct IORequest *)} Initiate a device operation.
See the Exec Device API for details.

\item{LONG HIDDM_AbortIO (struct IORequest *)} Abort a running device
operation. See the Exec Device API for details.

\item{HIDDT_Config HIDDM_LoadConfigPlugin (APTR PluginData)}
Tells the HIDD to load its configuration plugin. This method returns
a pointer to the plugin. |PluginData| is a pointer with plugin
specific data. For details, look into the manual for the HIDD.

\end{methods}

\section{The HIDD Config Plugin API}

\begin{methods}
\item{LONG OM_SET (struct TagItem * AttrList)}
Change some attributes of a HIDD Config Plugin (HIDD CP).

The return code is 0 in case of success or != 0 in case of an error.
If the return code is > 0, then it's the number of the offending tag in the
list, if it's < 0, then it's an error code.
You can use |HIDDM_ValueToString()| with the special tag |HIDDA_ErrorCode|
to convert this error code into a string.

Note that changing attributes changes only the HIDD CP, never the HIDD
itself. When the HIDD CP tells you that the current config works, then
you can copy the config to the HIDD.

\item{LONG OM_GET (Tag AttrID, IPTR * Storage)} Query a single attribute
from the HIDD CP. You can only query attributes which are gettable.

The return code is 0 in case of success or < 0 in case of an error.
You can use |HIDDM_ValueToString()| with the special tag |HIDDA_ErrorCode|
to convert the error code into a string.

\item{LONG OM_MGET (struct TagItem * AttrList)} Query one or more attributes
from the HIDD CP. You can only query attributes which are gettable. The
|ti_Data| fields of |AttrList| must be pointers of the type which is
expected for the respective attribute.

The return code is 0 in case of success or != 0 in case of an error.
If the return code is > 0, then it's the number of the offending tag in the
list, if it's < 0, then it's an error code.
You can use |HIDDM_ValueToString()| with the special tag |HIDDA_ErrorCode|
to convert this error code into a string.

\item{struct TagItem * AttrList HIDDM_QueryConfig (void)}
Ask the HIDD CP about its current configuration. The AttrList
should be built in such a way that one can go back to the current config by
loading the device for the first time and use |OM_SET| with this AttrList
or by disabling it and use |OM_SET|. A typical use of this will be to save
this list to a file and load it next time when one needs to configure the
HIDD.

The current configuration of the HIDD CP is a copy of the HIDDs current
configuration when the HIDD CP is created. Then you can change it and the
HIDD CP will act as if the HIDD itself had changed. When you are done, you
can apply the changes to the HIDD itself (aka Ok or Apply) or just forget
about them (aka Cancel).

Tip: If you write a HIDD, then you can use the power of BOOPSI and
TagItem lists to create this list. Pass this method to the superclass
first and then attach your local taglist with |TAG_MORE|. Or you can filter
the taglist of the superclass and build your own taglist (and dispose
the taglist of the superclass by |HIDDM_FreeConfig()|).

\item{void HIDDM_FreeConfig (struct TagItem * AttrList)}
Dispose the list of attributes which you got by |HIDDM_QueryConfig()|.

\item{struct TagItem * HIDDM_QueryModeList (void)}
Ask the HIDD CP about the currently available modes.

The taglist consists of tags which have the types |BOOL|,
|HIDDT_Limit| (a min and max value), |HIDDT_List| (a list with
string/value pairs or one-of-many selection) or |HIDDT_OptionList| (same as
|HIDDT_List| but for some-of-many selection. The result is
passed as a bitfield).

HIDD CPs which supply their own GUI don't need to support this
tag (but most will because you need something like this internally
anyway).

\item{void HIDDM_FreeModeList (struct TagItem * AttrList)}
Dispose the list of attributes which you got by |HIDDM_QueryModeList()|.

\item{ULONG HIDDM_Apply (void)} Apply the current config to the HIDD.
If you dispose the HIDD CP, then all changes will be lost.

\item{STRPTR HIDDM_ValueToString (Tag tag, IPTR value)} Convert the
value |value| for the tag |tag| into a human readable string.
The string returned must not be written to or be freed.

HIDD CPs which supply their own GUI don't need to support this
tag (but most will because you need something like this internally
anyway).

The application will use this value to generate the visual feedback
in its GUI.

\item{IPTR HIDDM_StringToValue (Tag tag, STRPTR string)} Convert
the string |string| for the tag |tag| back into a value.

HIDD CPs which supply their own GUI don't need to support this
tag (but most will because you need something like this internally
anyway).

Also note that a HIDD can ask that you return exactly the string
which was passed to you by |HIDDM_ValueToString()| (ie. the
string must have the same address).

\item{STRPTR HIDDM_GetTagName (Tag tag)} Return a human readble string
with the name for a tag. For example a serial HIDD with the
tag |HIDDV_Serial_Baudrate| might return |"Baud rate"|. The
application will use this to generate its GUI.

\end{methods}

\subsection{Common tags for all HIDDs}

\begin{taglist}
\item{HIDDA_Type,ULONG,G} This is the basic type of the HIDD (eg.
|HIDDV_Type_Serial| for serial HIDDs, |HIDDV_Type_Parallel| for parallel
HIDDs or |HIDDV_Type_Graphics| for graphical HIDDs).

\item{HIDDA_SubType,ULONG,G} This is a more specific type. If |HIDDA_Type| is
|HIDDV_Type_Serial|, then this is a bitfield with one or more bits
of |HIDDV_Type_Serial_RS232| or |HIDDV_Type_Serial_RS488| set.

\item{HIDDA_Producer,ULONG,G} The ID of the producer as handed out by Amiga
International.

\item{HIDDA_Name,STRPTR,G} The name of this device (eg. serial.device).

\item{HIDDA_HardwareName,STRPTR,G} The name of the hardware
(eg. "Builtin Serial Port", "COM1", "CyberVision/3D", etc.). Note that
you must initialize some HIDDs before you can query this attribute
because some HIDDs work with more than one type of hardware.

\item{HIDDA_Active,BOOL,ISG} Tells if the device is active or
(de-)activates it when set.

\item{HIDDA_Status,ULONG,G} The current status of a HIDD. This is a
set of bits which show if the init of the hardware was successful,
if the device is active or if the device is ready to be activated.

\item{HIDDA_ErrorCode,LONG,G} In case of an error, you can ask
for the error code and use this code in |HIDDM_ValueToString()|
to get a string with the meaning of the error. This is mostly used
when the HIDD tells you that it doesn't like a certain tag in a
taglist. When this happens, you can query this code to find out
what the HIDD doesn't like about the tag.

\end{taglist}

\subsection{Common tags for all HIDD CPs}

\begin{taglist}
\item{HIDDA_HasOwnGUI,BOOL,G} Ask the HIDD CP if it has its own GUI
for configuration.

\item{HIDDA_ShowGUI,BOOL,ISG} Make the GUI of the HIDD CP visible
or hide it or ask if it's visible right now. If you hide the GUI
and dispose the HIDD CP, then the changes the user made will be
lost.

\item{HIDDA_UseScreen,struct Screen *,ISG} Tell the HIDD CP to open the
GUI on this screen.

\item{HIDDA_AppMsgPort,struct MsgPort *,ISG} When the HIDD CP has its own
GUI, this GUI runs independend of the application. You can supply a message
port to synchronise your application with the GUI of the HIDD CP. Some HIDD
CPs will also use this to talk to the application.

\end{taglist}

\subsection{Tags for some HIDDs}

\begin{taglist}
\item{HIDDA_Shared,ULONG,ISG} Allow to share a HIDD with other
applications or lock it for single use. This might be used in HIDDs like
sound HIDDs, serial HIDDs, graphics HIDDs, etc. Not all HIDDs need to
supported shared access (see below).

Values for |HIDDA_Shared| are:

\begin{description}
\item{HIDDV_Shared_Exclusive} Try to get the HIDD exclusively.
If someone else has locked the HIDD exclusive or shared already,
this will fail.

\item{HIDDV_Shared_Shared} Try to share the HIDD with other
apps. This will fail if someone else has already locked the
HIDD exclusively.

\item{HIDDV_Shared_NonExclusive} Use this mode if it doesn't matter if
you can't get it. This might be used for apps which want to play sounds in
the background when someone inserts a disk into the drive or similar. HIDDs
accessed with this value set might loose access permissions while locked.
Nevertheless applications without access permission may still perform
methods on this object. These methods are discarded.

\item{HIDDV_Shared_NotAvailable} This can only read back. If the
attribute contains this value, the HIDD doesn't support sharing.

\item{HIDDV_Shared_Lock} Some HIDDs can be shared but used only by one
application at a time. An example might be the CPU. There is only one CPU
but different applications might want to get it.

If the HIDD supports this, you must set the attribute to
|HIDDV_Shared_Shared| and when you want to get the HIDD, set the attribute
to |HIDDV_Shared_Lock|. When this succeeds, whoever had the HIDD will loose
control on the HIDD and you will get it. Some HIDDs will tell you when you
lost control or will tell you when you are about to loose control and allow
you to prevent that or clean up.

\end{description}

\end{taglist}

\section{Sample HIDDs}

\subsection{Serial HIDD}

The type of a serial HIDD is |HIDDV_Type_Serial| and the names
for serial specific things is prefixed with |HIDD?_Serial_|.

Subtypes of serial HIDDs are |HIDDV_RS232| and |HIDDV_RS488|, for
example.

\begin{taglist}
\item{HIDDA_Serial_BPSRate,ULONG,ISG} The bits per second or a logical BPS
rate (300baud, 600baud, 1200baud, 2400baud, 4800, 9600, 19200, 31500
(MIDI), 38400, etc.) The logical BPS rates have the bit 31 set.

When you query the list of available modes, you will get an |HIDDT_Limit|
for this attribute. If the limits have bit 31 set, the device supports only
fixed BPS rates. If the limits don't have this bit set, this means that the
device supports variable BPS rates. If you use a logical BPS rate, you must
make sure that you don't exceed the limits. For example, some device might
support any BPS rate between 5000bps and 100000bps. This means that only
the logical BPS rates between 9600 and 74k (including both) are available.

Also note that a HIDD might not support every BPS rate in the range. There
might be arbitrary steps, so you must set the BPS rate and then read it
back to see what the HIDD can do. The HIDD should always select a BPS
rate which is next to the one the user wants.

\item{HIDDA_Serial_DataLength,ULONG,ISG} The number of data bits. Most
HIDDs support only 7 or 8 bits but you should expect at least anything
between 5 and 8.

\item{HIDDA_Serial_StopBits,ULONG,ISG} The number of stopbits between
two data bytes multiplied by 16 (ie. one stopbit is 16, one and a half
would be 24 and two stopbits is 32).

\end{taglist}

\subsection{Keyboard HIDD}

\begin{methods}
\item{ULONG HIDDM_QueryKeys (ULONG ** keyptr)} Ask for all really
available keys on this keyboard. The method will fill in a pointer to
a read-only array and return the number of elements in that array.
You must not free this array nor write to it.

\item{ULONG HIDDM_QueryKeyStates (ULONG ** keyptr)} Ask for all currently
pressed keys on this keyboard. The method will fill in a pointer to
an array and return the number of elements in that array.

\item{ULONG HIDDM_FreeKeyStates (ULONG * keyptr)} Free the result of
a |HIDDM_QueryKeyStates()|.

\end{methods}

\begin{taglist}
\item{HIDDA_Keyboard_Type,ULONG,ISG} If the Keyboard HIDD can work with more
then one type of keyboard, you can specify the type here or if the HIDD
can figure the type of keyboard itself, it can offer the type here.
If the HIDD doesn't support this, this value is |0| and can't be changed
by setting it. The method |HIDDM_QueryModes()| should return a type
|HIDDT_Limit| with min and max both 0.

\item{HIDDA_Keyboard_MsgPort,struct MsgPort *,ISG} When the user presses a
key, the HIDD should report this by sending a |HIDDT_Keyboard_Event|
message to this port. The message looks like this:

\begin{code}
typedef struct
{
    struct Message ke_Message;
    ULONG	   ke_Key[1];
}
HIDDT_Keyboard_Event;
\end{code}

|ke_Key[]| contains the X11 code for the key. See
\filename{/usr/include/X11/keysymdef.h} for available keycodes.
If the key has been pressed, bit 31 will be set. If the key has
been released, bit 31 will be cleared.

If the user pressed more then one key, the other keys are in
|ke_Key[1]|, |ke_Key[2]|, etc. The number of keys in the message
is calculated by the macro |HIDDQ_Keyboard_GetNumKeys(msg)|.

\end{taglist}

\subsection{Graphics HIDD}

The graphics HIDD supports the following methods:

\begin{methods}
\item{IPTR HIDDM_Graphics_QCmd,UWORD Length,UWORD Command,...)}
Make the HIDD execute a simple command. Simple commands execute
very fast and don't do any checks. They were implemented to give
you raw speed when you need it.

|Command| is the command to execute and |Length| is the size
of the command (including both |Command| and |Length|).

The result of |HIDDM_Graphics_QCmd()| depends on the command
which is to be executed.

\item{IPTR HIDDM_Graphics_Cmd,UWORD Length,UWORD Command,...)}
Make the HIDD execute a command. The commands executed this
way are checked for validity (eg. clipping is performed) and
they may take very long to execute.

|Command| is the command to execute and |Length| is the size
of the command (including both |Command| and |Length|).

The result of |HIDDM_Graphics_Cmd()| depends on the command
which is to be executed.

\item{IPTR HIDDM_Graphics_MCmd,UWORD length,UWORD length1, UWORD cmd1,
...)} This is like |HIDDM_Graphics_Cmd()| but executes more than one
command at once. |length| is the size of all commands plus all parameters.
The format of the separate commands is the same as in
|HIDDM_Graphics_Cmd()|.

\item{IPTR HIDDM_Graphics_MQCmd,UWORD length,UWORD length1, UWORD cmd1,
...)} This is like |HIDDM_Graphics_QCmd()| but executes more than one
command at once. |length| is the size of all commands plus all parameters.
The format of the separate commands is the same as in
|HIDDM_Graphics_QCmd()|.

\end{methods}

\begin{methods}
\item{HIDDT_BitMap HIDDV_Graphics_Cmd_CreateBitMap (UWORD width, UWORD
height, UWORD depth)} Create a drawing area with the specified size
and number of colors.

\item{void HIDDV_Graphics_Cmd_DeleteBitMap (HIDDT_BitMap bm)}
Return a drawing area for reuse. You can also dispose it with
|DisposeObject()|.

\item{HIDDT_GC HIDDV_Graphics_Cmd_CreateGC (HIDDT_BitMap bm)}
Create a graphics context. The graphics context is used to store
information which is needed for more than one command (for example
the color or the drawmode). A GC is a BOOPSI object and can be
changed with the normal BOOPSI API.

\item{void HIDDV_Graphics_Cmd_DeleteGC (HIDDT_GC gc)} Return a gc for
reuse. You can also dispose the GC with |DisposeObject()|.

\item{BOOL HIDDV_Graphics_Cmd_CopyArea (HIDDT_BitMap src, WORD
srcX, WORD srcY, UWORD width, UWORD height, HIDDT_GC dest, WORD destX,
WORD destY)} Copy a rectangular area from the drawing area |src| to the
drawing area stored in |dest| (which may be |src|). The source area is not
changed (except both rectangles overlap). The mode of the GC |dest|
determines how the copy takes place.

In quick mode, the following restrictions are not checked: It's not checked
whether the source or destination rectangle is completely inside the valid
area or whether the areas overlap. If they overlap, the results are
unpredictable.

\item{BOOL HIDDV_Graphics_Cmd_SetPixel (HIDDT_GC gc, WORD x, WORD y)}
Changes the pixel at (|x|,|y|) to the color stored in |gc|. This command is
available in quick and normal mode.

If the command is executed in normal mode, the coordinates are checked. If
the pixel could be set, the command will return 1 else 0.

In quick mode, the pixel is always set, even if the coordinates are
illegal, and it will always return 1 (but might crash the machine if
the coordiantes are invalid).

\item{ULONG HIDDV_Graphics_Cmd_GetPixel (HIDDT_GC gc, WORD x, WORD y)}
Queries the color of the pixel at (|x|,|y|). This command is available in
quick and normal mode. When executed in quick mode, the color will be
returned as the physical value for that color in the format used by the
HIDD. If the command is executed in normal mode, the coordinates are
checked and the color returned is a logical color (ie. a 24bit RGB value).
If the pixel could be queried, the command will return its value
and ~0 (ie. all bits set) otherwise.

Note that in quick mode, the command always returns something
but if the coordinates are outside the valid coordinates, this can
crash your machine or return random values.

\item{BOOL HIDDV_Graphics_Cmd_DrawLine (HIDDT_GC gc, WORD x1, WORD y1, WORD
x2, WORD y2)} Draws a line from (|x1|,|y1|) to (|x2|,|y2|) in the specified
gc. This command is available in quick and normal mode. In normal mode, the
line is clipped against the drawing area.

\item{BOOL HIDDV_Graphics_Cmd_DrawRect (HIDDT_GC gc, WORD x1, WORD y1, WORD
x2, WORD y2)} Draws a hollow rectangle from (|x1|,|y1|) to (|x2|,|y2|) in
the specified gc. This command is available in quick and normal mode. In
normal mode, the rectangle is clipped against the drawing area.

\item{BOOL HIDDV_Graphics_Cmd_FillRect (HIDDT_GC gc, WORD x1, WORD y1, WORD
x2, WORD y2)} Draws a solid rectangle from (|x1|,|y1|) to (|x2|,|y2|) in
the specified gc. This command is available in quick and normal mode. In
normal mode, the rectangle is clipped against the drawing area.

\item{BOOL HIDDV_Graphics_Cmd_DrawEllipse (HIDDT_GC gc, WORD x1, WORD y1, WORD rx, WORD
ry)} Draws a hollow ellipse from (|x1|,|y1|) with the radii
|rx| and |ry| in the specified gc. This command is available in quick and
normal mode. In normal mode, the ellipse is clipped against the drawing
area.

\item{BOOL HIDDV_Graphics_Cmd_FillEllipse (HIDDT_GC gc, WORD x1, WORD y1, WORD rx, WORD
ry)} Draws a solid ellipse from (|x1|,|y1|) with the radii
|rx| and |ry| in the specified gc. This command is available in quick
and normal mode. In normal mode, the ellipse is clipped against the
drawing area.

\item{BOOL HIDDV_Graphics_Cmd_DrawPolygon (HIDDT_GC gc, UWORD n, WORD
coords[2*n])} Draws a hollow polygon from the list of coordinates in the
specified gc. This command is available in quick and normal mode. In normal
mode, the polygon is clipped against the drawing area and no point is drawn
twice.

\item{BOOL HIDDV_Graphics_Cmd_FillPolygon (HIDDT_GC gc, UWORD n,
WORD coords[2*n])}
Draws a solid polygon from (|x1|,|y1|) to (|x2|,|y2|)
in the specified gc. This command is available in quick and normal mode.
In normal mode, the polygon is clipped against the drawing area and no
point is drawn twice.

In quick mode, the polygon should be convex, otherwise the results are
unpredictable.

\item{BOOL HIDDV_Graphics_Cmd_DrawText (HIDDT_GC gc, WORD x, WORD y, STRPTR
text, UWORD length)} Draws the first |length| characters of |text| at
(|x|,|y|). This command is available in quick and normal mode. In normal
mode, the text is clipped against the drawing area.

\item{BOOL HIDDV_Graphics_Cmd_FillText (HIDDT_GC gc, WORD x, WORD y, STRPTR
text, UWORD length)} Fills the area of the text with the background color
and draws the first |length| characters of |text| at (|x|,|y|). This
command is available in quick and normal mode. In normal mode, the text is
clipped against the drawing area.

\item{BOOL HIDDV_Graphics_Cmd_FillSpan (HIDDT_GC gc, HIDDT_Span span)}
Draws a solid from a shape description in the specified gc. This command is
available in quick and normal mode. In normal mode, the spans are clipped
against the drawing area.

\item{void HIDDV_Graphics_Cmd_Clear (HIDDT_GC gc)} Sets all pixels of the
drawing area to the background color stored in |gc|. This command is
available in quick and normal mode and behaves similar in both modes.

\item{IPTR HIDDV_Graphics_Cmd_Special (...)} This is for HIDD specific
commands. You can use this for sending commands to the HIDD which are not
covered by this doc. This command is available in quick and normal mode.
It's behaviour is HIDD specific.

\end{methods}

\begin{taglist}
\item{HIDDA_Graphics_Mode,ULONG,ISG} The display mode. Every HIDD defines
its own list and uses its own values. Use the method
|HIDDM_ValueToString()| to get the meanings of this attribute.

\item{HIDDA_Graphics_Width,ULONG,ISG} This is the width of the available
drawing area in units. Some graphics HIDDs support text mode; then this
is in characters. Most of the time, this will be in screen or
printer pixels.

\item{HIDDA_Graphics_Height,ULONG,ISG} This is the height of the available
drawing area in units. Some graphics HIDDs support text mode; then this
is in characters. Most of the time, this will be in screen or
printer pixels.

\item{HIDDA_Graphics_Depth,UWORD,ISG} This is the number of available
color bits. Use |1 << depth| to get the number of colors. Most HIDDs
will support depths like 1, 8, 15, 16, 24 and 32 bit.

\item{HIDDA_Graphics_BaseAddress,APTR,ISG} This is the address of the RAM
of the graphics memory. Note that most HIDDs don't support to set this
value. This can be used to access the video hardware directly. If you
plan this, you must check if the HIDD supports this and if it does,
then you must take the appropriate steps specified in the HIDDs' docs
to tell the HIDD what you are doing (eg. disable the HIDD).

\item{HIDDA_Graphics_BestSize,ULONG,G} Query the HIDD for the best size
for drawing areas or drawing commands. Most graphics chips have
a certain blocking size, ie. it doesn't matter if you copy 6 bits or
30 but 33 is slow. The HIDD will return 32 in this case.

\end{taglist}

A HIDDs' GC has the following attributes:

\begin{taglist}
\item{HIDDA_GC_UserData,APTR,SG} The user can store arbitrary
data in here.

\item{HIDDA_GC_BitMap,HIDDT_BitMap,G} This is the bitmap which
is connected to this GC.

\item{HIDDA_GC_Foreground,ULONG,SG} This is the forground color.

\item{HIDDA_GC_Background,ULONG,SG} This is the forground color.

\item{HIDDA_GC_DrawMode,ULONG,SG} This is the draw mode. There are
16 possible modes and they are defined as follows:

\begin{code}
dest = ((mode & 1) && src && dest)
    || ((mode & 2) && src && !dest)
    || ((mode & 4) && !src && dest)
    || ((mode & 8) && !src && !dest)
;
\end{code}

The most useful values are |HIDDV_GC_DrawMode_Copy| (|0x03|) which copies
src into dest (this is the default) and |HIDDV_GC_DrawMode_XOr| (|0x06|)
which inverts dest according to src.

\item{HIDDA_GC_Font,HIDDT_Font,SG} The current font.

\item{HIDDA_GC_ColorMask,ULONG,SG} Prevents some color bits from changing.
This attribute is only considered in normal mode. This can slow rendering
somewhat.

\item{HIDDA_GC_LinePattern,UWORD,SG} Provide a simple pattern while
drawing lines. This attribute is only considered in normal mode.

\item{HIDDA_GC_PlaneMask,HIDDT_BitMap,SG} This is a shape bitmap. When
drawing into the destination bitmap, only those bits will be changed
where this bitmap has bits set. This bitmap can be smaller than the
destination bitmap; bits outside this bitmap are considered to be 0.

To disable this, set the attribute to |NULL| (this is also the default).
Note that enabling this slows rendering down, sometimes very much.

\end{taglist}

\subsection{Sound HIDD}

Okay, here are some examples, how a sound.hidd could be implemented on
different hardware-bases. This is how the class would behave, if a method
HIDDM_SendMIDI was sent (I don't know, if such a method would make sense,
but it's only for illustration issues).

Amiga with internal sound (subclass of hiddclass):

There are two possibilities, how to handle it. The first is, not to handle
it, so that the method is passes on to the hiddclass (which doesn't know
this method either) and then on to the rootclass, which returns 0 (FALSE)
on unknown methods. The second possibility is to implement it in
soundhiddclass and return FALSE immediatly (because we know that the
internal Amiga soundsystem can't handle MIDI).

Amiga with sound-card on zorro-bus (subclass of zorroclass):

The sound-card passes all methods through to its superclass, except methods
for playing/receiving/whatever music. It can either implement them totally
on its own or might use some features of its superclass, for example a
general method for sending data to a zorro-card.

Amiga with internal sound or soundcard and additional MIDI-card:

This configuration would have two HIDDs, one for MIDI only and one for
sound in general. For the implementation of the last one see above (either
Amiga with internal sound or Amiga with sound-card). The MIDI HIDD-class
could subclass the general sound class (without knowing, if it is capable
of playing MIDI) and pass on all methods except MIDI relevant methods. It
would fully overload these. Another solution would be to subclass hiddclass
directly and ignore every non-MIDI sound command. While the general class
would be unit 0, the MIDI class would be unit 1, so that an application can
choose between the normal sound-system (either the internal Amiga
soundsystem or a sound-card, which might have MIDI capabilities on its own)
or the MIDI card. If the MIDI class would subclass the normal soundhidd, it
would feature non-MIDI sound, too (by passing the methods on). Of course,
it had to pass a query to a HIDDA_Capabilities attribute on to the
superclass, so that the capabilities of the superclass can be recognized by
the application for unit 1, too.

PC with soundblaster-super-ultra-pro-whatever:

This HIDD could(!) subclass a class, which handles soundblaster-cards in
general, i.e. the functions that are common to all soundblaster-card (which
itself could subclass something like a pcbusclass). Normally this class
would pass all methods on to its superclass, but it could implement some
methods on its own or partly overload some methods, where this specific
soundblaster-card had advantages/different features than the other
soundblaster-cards.

o Some thoughts about the sound.hidd:

  o An attribute HIDDA_Capabilities [..G], which could define things like:
    o HIDDV_Sound_MIDI - sound-system is able to play MIDI sounds (possibly by
      using an external MIDI device, such as a keyboard)
    o HIDDV_Sound_SFX - sound-system is capable of playing simple sounds (e.g.
      the internal pc-speaker)
    o HIDDV_Sound_Music
    o HIDDV_Sound_Speech

  o Possibly attributes HIDDA_Sound_ActivateHook, ..._InactivateHook [ISG]
    These attributes could be used by an application to provide hooks, which
    are called, if a not-locked unit is exclusively locked by another
    application (or this exclusive lock is freed). So these attributes
    makes only sense with HIDDV_Sound_NonExclusiveNotLocked.

\section{Internals}

A HIDD is a normal Exec Device which creates a BOOPSI class when
loaded. A HIDD is recognised by the name in the ROMtag structure.
This name must begin with the four letters "HIDD" (in that order).
Note that the name of the HIDD is the string after the first four
letters. Also note that a HIDD need not have a unique name.

Every HIDD has an extended ROMtag structure which contains the
infos needed to find a HIDD by |HIDD_FindHIDD()|.

HIDDs are BOOPSI objects but unlike other BOOPSI objects, they
are not created by classname but by the pointer returned by
|HIDD_FindHIDD()|.

\section{Random unsorted ideas}

\end{new}

