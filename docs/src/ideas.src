\begin{new}{16.10.1997}
\chapter{Random Ideas}
\section{Introduction}

This part of the documentation for AROS contains random and unsorted and
possibly impossible improvements, ideas and other things which might
go into AROS V2.x, when compatibility with AmigaOS is still important but
where new things can be done.

\begin{itemize}
\item By Nils Henrik Lorentzen: All lists and public structures must be protected by semaphore. A
system like the hierarchical semaphores in pOS would be best.
\item By Claus Herrmann and Iain Templeton:
lddaemon should be able to load more than one library at a time thus
allowing to open a library which has to be loaded from disk which opens a
library in |libOpen()| which has also to be loaded from disk.

The daemon could also search actively for a library allowing the user to
specify one if it can't be found. Paths like \shell{PROGDIR:} should be
searched automatically.

If the lib can't be found, DOS_OpenLibrary() must create a message port and
a message, put the port in the reply-to field of the message as well as the
name and min-version of the lib and then send the message to the lddaemon
and wait for the reply.

Open questions: Will this interfere with the way Exec handles libraries now
(eg. single threaded |libInit()|) ? Can this introduce deadlocks in the
locking of the exec library list ? What happens if |libClose()| calls
|libExpunge()| ?
\item
\begin{new}{27.10.1997}
By Nils Henrik Lorentzen: Extend on the
datatypes concept. Some datatypes-alike system where dataprocessing methods
can be added to datatype classes. (Eg. for pictures one could add methods
like |Rotate()|, |Flip()| and other typical image processing operators.
Similarly one can add sound fx methods for sound data). For this to be
usefull one should probably be able to add methods to a class one by one
(so BOOPSI can probably not be used for this).

The objects should contain the data in a raw format so that the methods
can easily operate on it. One should be able to stream data in and out
of the objects. One could have separate "converter objects" that
can convert from a data format (eg. GIF->internal raw image format
and back eg. raw->GIF.) So when you want to put a GIF file into
a image object the system will automatically search for installed
gif->internal raw converters and convert the GIF into a stream of
raw image data passed to the image object.

These data objects should of course have methods like |Show()|
and |Edit()|. |Edit()| could invoke your favourite
texteditor/paintprogram/drawprogram/etc depending on the
object type. (text/image/structured drawing).

Now, should these objects be able to show themselves,
like the old datatypes ? Well, IMO they should not be bound to
a single operating system/GUI system, but they could maybe show
themselves through some RTG system (?).
But the viewer could also stream out the data from
the object to show. When the object's data has changed, the
viewer could be notified and where in the stream the "damaged" data is.
(If a text viewer GUI views the first 100 lines of a 100000 line
text data object, and the last 100 lines are changed, it wouldn't
need to rerender).

As mentioned earlier one should be able to use this system
on different OSes, and it should maybe also be possible to
invoke methods on them over a network or even move the objects
in a network (using CORBA ?). This way a heavy operation on
the data object can be done on a faster machine while you are
controlling it from a slower machine.

By keeping functionality into small components, 3rd party
programmers can easily write freeware additional functionality.
(One can add methods operating on the data one at a time.)
It will provide very much reuse of code. (Just look around on
Aminet: There are whole bunch of different image processing
programs that implement the same functionality. This
should really only have to be written once).
If the system can work on other platforms too, we get even
more developers that can support it.

I believe that if some system should have any chance at all
of taking some market share from M$ it	a) has to be free.
b) must be available on as many platforms as possible. c) must consist
of tiny components that can be added at run-time.=>This way it'll be
easier for developers to support it.
\end{new}

\item
\begin{new}{27.10.1997}
When a new HIDD is installed, it should appear in the list of
available HIDDs automatically (eg. by file notification on the directory).
\end{new}

\item
\begin{new}{27.10.1997}
We need an automatic converter for the incompatible features of AROS
to convert the old AmigaOS code to AROS (which can then be compiled on
AmigaOS by our compatibility lib).
\end{new}
\end{itemize}
\end{new}
