\chapter{The AROS Filesystem Interface}

Normally, as an application programmer, you don't have to worry about the
filesystem interface -- you can do everything you want via simple calls
to DOS. However you may need to know how to interface with a filesystem 
if you
\begin{itemize}
\item	Need to write your own filesystem,
\item	Wish to asynchronous I/O,
\item	Are writing a console driver,
\item	Don't trust DOS.
\end{itemize}

Of the above the most useful of these would be doing asynchronous I/O, although
it is in many cases better to use one of the publically available libraries
to do this, as it will hide from you the implementation of the filesystems.

\section{It's Completely Different}
The interface to filesystems is different under AROS compared to AmigaOS in
many ways
\begin{itemize}
\item	filesystems are exec devices not process's |MsgPort|'s. This gives
	two main benefits -- it is possible to do some work on the callers
	schedule, which for simple requests can save on two context switches;
	and it gives us a way to abort a request, which is an important 
	feature for a network filesystem.
\item	There is no difference between locks and filehandles anymore. This
	avoids requiring redundant methods such as |ACTION_FH_FROM_LOCK|.
\item	No BCPL -- everything is a C data type or a string. A side effect
	of this is that there is no limit on string size which translates
	to no limit on filename size either.
\end{itemize}

Obviously this change renders the filesystem incompatible to the current
AmigaOS filesystems and DOS implementation. However it should be possible
to build a bridge between the filesystems if necessary.

\section{Filesystem Devices}
The major API change with filesystems is that they now use the Exec Device
API. You can use the normal device functions (|DoIO()|, |AbortIO()|, etc).
The I/O Request structure is defined in dos/filesystems.h:

\begin{code}

/* IORequest from <exec/io.h> */
struct IORequest 
{
	struct Message	io_Message;
	struct Device  *io_Device;	/* filesystem base pointer */
	struct Unit    *io_Unit;	/* file or directory handle */
	UWORD		io_Command;	/* the command */
	UBYTE		io_Flags;	/* normal device flags (IOF_QUICK) */
	BYTE		io_Error;	/* error code from device functions */
};

struct IOFileSys
{
	struct IORequest IOFS;
	LONG		 io_DosError;	/* secondary error code (IoErr()) */
	union	{}	 io_Union;	/* arguments - command dependant */
};

\end{code}

The |io_DosError| field is used to return the secondary error code to the
caller. This is the code that is returned by the dos.library function
|IoErr()|. The io_Error field of struct IORequest should only be used to
return a simple failure/success for filesystem commands, and should have
the normal effect for the device open/close commands.

The |io_Union| field is an union containing different structures for each of the
commands. This field has a variable length depending upon the command. The 
fields listed in the INPUTS sections of the autodocs below refer to a specific
member of this union.

\section{Command Documentation}
\begin{autodoc}{filesys}

\subsection{OpenDevice}
\heading{NAME}
	OpenDevice("*.handler", 0, iofs, 0);

\heading{FUNCTION}
	Mount a new filesystem. The IOFileSys structure iofs passed to the
	handler should contain enough information for the handler to mount
	the filesystem.

	If there is a volume mounted in this device, it is the responsibility
	of the handler to add the required volume nodes to the DOS device
	list before returning to the caller. Note here that the DOS device
	list is already locked, so you do not need to lock it yourself.

	The filesystem must return a handle to the device in the io_Unit
	pointer of the struct IOFileSys. The io_Error and io_DosError
	fields should be set appropriately for success or failure.

\heading{INPUT}
	Union field - io_OpenDevice

	io_DeviceName -	name of the exec device to mount the filesystem 
			upon. This device is the underlying hardware of
			the device. Note that this field may not be valid
			for some special types of handlers (for example
			network filesystems or special devices - AUX:, SER:).
	
	io_Unit -	Unit number for the exec device. Note this is the
			io_Union.io_DeviceName.io_Unit field, not io_Unit.
	
	io_Environ -	This is a pointer to the struct DosEnvec which 
			describes this device.

\heading{RESULT}
	io_Device 	-	device base pointer.
	io_Unit	  	-	logical device handle.
	io_Error	-	IOERR_OPENFAIL or 0 for no error.
	io_DosError	-	DOS error code or 0 for no error.

\heading{SEE ALSO}
	CloseDevice

\subsection{CloseDevice}
\heading{NAME}
	CloseDevice

\heading{FUNCTION}
	Try and dismount a DOS device. If there are any mounted volumes in
	the device, the filesystem should remove them from the DOS device
	list. Note that the DOS device list will have already been locked
	by the caller, so you will not have to do this yourself.

	You should not dismount the device if there are still open files
	or outstanding locks.

\heading{INPUT}
	io_Unit		-	logical device handle.

\heading{RESULT}
	The DOS device shall be dismounted if possible.

	io_DosError	-	dos error code or 0 if successful

\subsection{FSA_OPEN}
\heading{NAME}
	FSA_OPEN

\heading{FUNCTION}
	Create a handle to an existing file or directory. You can use this
	handle to read directories or read/write files.

	The filename io_Args[0] is relative to the path of the directory
	associated with the handle io_Unit. If io_Unit is NULL however,
	the filename should be taken as relative to the root directory of
	the device.

    	This command uses the io_Union.io_OPEN member.
    	
\heading{INPUT}
	io_Unit		-	handle to current directory.

    	io_Filename	-	relative file or directory name.
        io_FileMode	-	mode to open with:
    		FMF_LOCK	- lock exclusively
    		FMF_READ	- open for reading
		FMF_WRITE	- open for writing
    		FMF_EXECUTE	- open to execute

\heading{RESULT}
	io_Unit		-	Freshly created handle.
	io_DosError	-	dos error code or 0 for success.

\heading{SEE ALSO}
	FSA_OPEN_FILE, FSA_CLOSE

\subsection{FSA_CLOSE}
\heading{NAME}
	FSA_CLOSE - close an open file

\heading{FUNCTION}
	Close a file or directory handle. You should write out any buffered
	data before returning. It is the responsibility of the filesystem
	to free the data pointed to by io_Unit.

\heading{INPUT}
	io_Unit		-	handle to file or directory

\heading{RESULT}
	io_DosError	-	dos error code or 0 for success

\heading{SEE ALSO}
	FSA_OPEN, FSA_OPEN_FILE

\subsection{FSA_READ}
\heading{NAME}
	FSA_READ

\heading{FUNCTION}
	Try and read the requested number of bytes from the filehandle.
	A handler will normally try and fulfill the request completely,
	but special handlers (such as the console) may return less than
	the requested number of bytes.

	If you reach the end of the file, you should return the number
	of bytes read in the current attempt. On the next call you should
	return 0 for EOF. Any further attempts to read should result in
	a return of -1 with an error code.

    	This function uses the io_Union.io_READ_WRITE field.

\heading{INPUT}
	io_Unit		-	filehandle

	io_Buffer	-	pointer to byte buffer
	io_Length	-	number of bytes to read from the file


\heading{RESULT}
	The buffer io_Buffer should contain some data if it was possible
	to read any.

	io_Length	-	number of bytes read
	io_DosError	-	dos error code or zero for success

\heading{SEE ALSO}
	FSA_WRITE

\subsection{FSA_WRITE}
\heading{NAME}
	FSA_WRITE - Write to a file

\heading{FUNCTION}
	Try to write the requested number of bytes to the filehandle.
	A handler should try and fulfill the request completely, but
	special handlers may write less than the requested number of
	bytes.

	If you cannot write any bytes return 0 in io_Length.

    	This command uses the io_Union.io_READ_WRITE member.

\heading{INPUT}
	io_Unit		-	file handle
	io_Buffer	-	byte buffer containing data to write
	io_Length	-	number of bytes in buffer

\heading{RESULT}
	The contents of the buffer should have been written to the 
	stream.

	io_Length	-	The number of bytes actually written
	io_DosError	-	dos error code or 0 for success.

\heading{SEE ALSO}
	FSA_READ

\subsection{FSA_SEEK}
\heading{NAME}
	FSA_SEEK - Seek within a file

\heading{FUNCTION}
	This command shall change the position of the next read or write
	in the file. The command will also return the old position in the
	file.

	Note: A command with io_Negative = io_Offset = 0, and 
	      io_SeekMode = OFFSET_CURRENT is a NOP in terms of seeking
	      and will simply return the current file position.

	XXX: Error condition for seeking before the start, and after the
	     end of file.

    	This command uses the io_Union.io_SEEK member.

\heading{INPUT}
	io_Unit		-	Filehandle
	io_Negative	-	upper half of offset (bits 63-32)
	io_Offset	-	lower half of offset (bits 31-0)
	io_SeekMode	-	mode

		OFFSET_BEGINNING	- offset is relative to the
					  beginning of the file
		OFFSET_CURRENT		- offset is relative to the
					  current position 
		OFFSET_END		- offset is relative to the
					  end of the file

\heading{OUTPUT}
	io_Negative	-	upper half of old position (bits 63-32)
	io_Offset	-	lower half of old position (bits 31-0)
	io_DosError	-	dos error code or 0 for no error


\subsection{FSA_SET_FILE_SIZE}
\heading{NAME}
	FSA_SET_FILE_SIZE - Set the size of a file

\heading{FUNCTION}
	Change the size of a file.

	If the old file size is less than the new size, then the file
	is simply truncated. If the file is made larger, then the data
	contained in the new section is invalid.

    	This command uses the io_Union.io_SEEK member.

\heading{INPUT}
	io_Unit		- filehandle
	io_Negative	- upper half of offset (bits 63-32)
	io_Offset	- lower half of offset (bits 31-0)
	io_SeekMode	- mode

		OFFSET_BEGINNING	- offset is relative to the
					  beginning of the file
		OFFSET_CURRENT		- offset is relative to the
					  current position 
		OFFSET_END		- offset is relative to the
					  end of the file

\heading{RESULT}
	The file will be the new size.

	io_DosError	- dos error code or 0 for success

\heading{NOTES}
	Not all handlers will support this command.


\subsection{FSA_WAIT_CHAR}
\heading{NAME}
    	FSA_WAIT_CHAR - wait for a character to arrive
    	
\heading{FUNCTION}
    	This command will wait for a character to be ready for reading.
    	You should only wait for a maximum of io_Timeout microseconds.
    	If io_Timeout is 0, then you should wait indefinately.

    	This command can be used on both plain files and interactive files.
    	For plain files it should return immediately, unless for some reason
    	there is no data available (a PIPE or a network file where there is
    	no data yet).

    	This command uses the io_Union.io_WAIT_CHAR member.

\heading{INPUT}
    	io_Unit     	- filehandle to wait on
    	io_Timeout  	- number of microseconds to wait for input

\heading{RESULT}
    	io_Success  	- set to TRUE if a character arrived in time.
    	io_DosError 	- set to the DOS error code, or 0 for no error

\heading{SEE ALSO}
    	FSA_IS_INTERACTIVE
    	
\subsection{FSA_FILE_MODE}
\heading{NAME}
    	FSA_FILE_MODE - set the mode of a file
    	
\heading{FUNCTION}
    	Apply a new mode to the file. This command uses a mask to define which
    	of the modes should be changed. Supplying a mask of 0 will return the
    	current set of modes.

    	This command uses the io_Union.io_FILE_MODE member.

\heading{INPUT}
    	io_Unit     	- filehandle to change mode on
    	io_FileMode 	- new modes to apply to the file
    	io_Mask     	- mask of modes which are to be changed.
    
\heading{RESULT}
    	The modes should be set to those described by the mask and mode flags.
    	
    	io_FileMode 	- the new set of filemodes
    	io_DosError 	- the DOS error code on failure, or 0 for success
    	
\subsection{FSA_IS_INTERACTIVE}
\heading{NAME}
    	FSA_IS_INTERACTIVE - is this file a terminal
    	
\heading{FUNCTION}
    	Query the filesystem as to whether this file is a interactive terminal.
    	
    	This function uses the io_Union.io_IS_INTERACTIVE member.

\heading{INPUT}
    	io_Unit     	- the filehandle to query
 
\heading{RESULT}
    	io_IsInteractive - TRUE if the file is interactive, FALSE otherwise
    	io_DosError 	- dos error code, or 0 for success.

\heading{SEE ALSO}
    	FSA_WAIT_CHAR

\subsection{FSA_SAME_LOCK}
\heading{NAME}
    	FSA_SAME_LOCK - are two locks the same?
    	
\heading{FUNCTION}
    	This function will compare two locks, and return whether the refer
    	to the same object in the filesystem.
    	
    	This command uses the io_Union.io_SAME_LOCK member.

\heading{INPUT}
    	io_Lock[0]  	- lock 1
    	io_Lock[1]  	- lock 2
    	
\heading{RESULT}
    	io_Same     	- set to LOCK_DIFFERENT or LOCK_SAME depending upon
    	    	    	  the result of the comparison.
    	io_DosError 	- DOS error code, or 0 for success.

\heading{SEE ALSO}
    	FSA_OPEN

\subsection{FSA_EXAMINE}
\heading{NAME}
	FSA_EXAMINE - example a file or directory

\heading{FUNCTION}
	This command will obtain information about the current file or
	directory and return it in the ExAllData structure passed in.

	We do not support passing filesystems the FileInfoBlock structure
	as that has limits upon the size of paths. The AROS dos.library
	will handle the translation between the two structures.

	You need only return the information requested, which is determined
	by the value in io_Mode.

    	This command uses the io_Union.io_EXAMINE

\heading{INPUT}
	io_Unit		- Handle to file or directory.
	io_ead		- struct ExAllData to be filled.
	io_Size 	- size of the buffer in bytes.
	io_Mode 	- type of information to obtain.

\heading{RESULT}
	io_DosError	- one of the DOS error codes, or 0 for success.

\heading{SEE ALSO}
	FSA_EXAMINE_ALL

\subsection{FSA_EXAMINE_ALL}
\heading{NAME}
	FSA_EXAMINE_ALL - Examine the contents of a directory

\heading{FUNCTION}
	Read the directory information of the current file or directory.
	If the handle is for a file, then you need only fill in the
	information for that file. You need only fill in the information
	requested by the caller.

	You should continue filling in information in the buffer until
    	you run out of space. The ed_Next fields of the ExAllData structure
	are used to link the entries together. The last entry should have
	ed_Next = NULL. Entries should be aligned to the size of the
	system pointer datatype.

	If io_DosError != 0, then the contents of the buffer is undefined.
	If you need space to store filenames, comments strings, etc these
	should be placed at the end of the buffer.

\heading{INPUT}
	io_Unit		- handle to a directory or file
	io_ead		- struct ExAllData[] buffer to be filled
	io_Size 	- size of the buffer in bytes
	io_Mode 	- type of information to get

\heading{RESULT}
	io_DosError	- dos error code or 0 for success.

\heading{SEE ALSO}
	FSA_EXAMINE, FSA_EXAMINE_ALL_END

\subsection{FSA_EXAMINE_ALL_END}
\heading{NAME}
    	FSA_EXAMINE_ALL_END - Finish examining a number of files.

\heading{FUNCTION}
    	Finish examining a number of objects in the filesystem. This is
    	used to reset the filesystems internal state if required.

    	This command does not use the io_Union field.

\heading{INPUT}
    	io_Unit     	- filehandle

\heading{RESULT}
    	io_DosError 	- DOS error code, or 0 for success.
    	
\heading{SEE ALSO}
    	FSA_EXAMINE, FSA_EXAMINE_ALL
    	
\subsection{FSA_OPEN_FILE}
\heading{NAME}
	FSA_OPEN_FILE

\heading{FUNCTION}
	Open a handle onto a file, creating the file if necessary. This
	command only works on files, not directories.

	Th
\heading{FUNCTION}
	Open a handle onto a file, creating the file if necessary. This
	command one io_Filename field gives the name of the file, which is
	relative to the handle passed in io_Unit. If the io_Unit handle is NULL, then
	the file is relative to the root of the directory tree.

    	This command also allows you to change the protection bits of the
    	file.

\heading{INPUT}
	io_Unit		-	handle to current directory.
	io_Filename	-	filename relative to io_Unit.
	io_FileMode	-	mode to open with:
		    FMF_LOCK	- lock exclusively
		    FMF_READ	- open for reading
    		    FMF_WRITE	- open for writing
    		    FMF_EXECUTE	- open to execute
		    FMF_CREATE	- create file if it doesn't exist
		    FMF_CLEAR	- delete file before opening
		    FMF_RAW	- open cooked console in raw mode (and vice
				  versa)
    	io_Protection	-   	The protection bits for the file.

\heading{RESULT}
	io_Unit		-	pointer to newly created handle.
	io_DosError	-	dos error code or 0 for success.

\heading{SEE ALSO}
	FSA_OPEN, FSA_CLOSE

\subsection{FSA_CREATE_DIR}
\heading{NAME}
	FSA_CREATE_DIR - Create a new directory

\heading{FUNCTION}
	This command tells the filesystem to create a new directory, 
	lock it, and return a handle to the lock. The directory 
	should be created with the modes given in io_Args[1].

	XXX: Is the lock read or write?

	The lock should be relative to the handle in io_Unit, or to
	the root directory if io_Unit == NULL.

\heading{INPUT}
	io_Unit		- handle to current directory, or NULL
	io_Filename	- relative name of directory to create
	io_Protection	- protection flags for the new directory

\heading{RESULT}
	The directory requested exists if it could be created.

	io_Unit		- handle to new directory
	io_DosError	- dos error code or 0 for sucess

\heading{SEE ALSO}
	FSA_OPEN

\subsection{FSA_CREATE_HARDLINK}
\heading{NAME}
    	FSA_CREATE_HARDLINK - Create a hard link to a file.

\heading{FUNCTION}
    	Create a hard link to a file. There is no difference between a hard
    	link and its original file. If the original file is deleted, the data
    	will still exist because of the link.

    	Hard links can not point across devices.
    	
    	This command uses the io_Union.io_CREATE_HARDLINK member.

\heading{INPUT}
    	io_Unit     	- handle to current directory, or NULL.
    	io_Filename 	- filename of the hard link.
    	io_OldFile  	- file to make the hard link towards.

\heading{RESULT}
    	A hard link will have been created if possible.

    	io_DosError 	- DOS error code, or 0 for success.

\heading{SEE ALSO}
    	FSA_CREATE_SOFTLINK
    	
\subsection{FSA_CREATE_SOFTLINK}
\heading{NAME}
    	FSA_CREATE_SOFTLINK - Create a soft link to a file.

\heading{FUNCTION}
    	Create a soft link to a file. There is a difference between a soft
    	link and its original file. If the original file is deleted, the soft
    	link will no longer be valid (but it will not be deleted).

    	As soft links are stored as the filename of the link to file, they
    	can be used across devices. This means that the filename stored
    	MUST be an absolute filename, as the current directory will be
    	unknown at read time.
    	
    	This command uses the io_Union.io_CREATE_SOFTLINK member.

\heading{INPUT}
    	io_Unit     	- handle to the current directory, or NULL.
    	io_Filename 	- filename of the soft link to create.
    	io_Reference  	- filename to make the soft link point towards.

\heading{RESULT}
    	A soft link will have been created if possible.

    	io_DosError 	- DOS error code, or 0 for success.

\heading{SEE ALSO}
    	FSA_CREATE_HARDLINK

\subsection{FSA_RENAME}
\heading{NAME}
    	FSA_RENAME - Rename an object in the filesystem

\heading{FUNCTION}
    	Rename an object in the filesystem. This function may be called on
    	a file which doesn't exist. The filenames specified should be
    	considered relative to io_Unit which specifies the current directory
    	(or NULL for the root directory).

    	Renaming a directory is equivalent to moving the entire contents of
    	the directory.

    	This command uses the io_Union.io_RENAME member.

\heading{INPUT}
    	io_Unit     	- handle to current directory (or NULL)
    	io_Filename 	- old filename
    	io_NewName  	- new filename    	

\heading{OUTPUT}
    	io_DosError 	- DOS error code, or 0 for success.

\subsection{FSA_READ_SOFTLINK}
\heading{NAME}
    	FSA_READ_SOFTLINK - Read the name of a softlinked file.

\heading{FUNCTION}
    	This command will read the name of the file referenced by file
    	io_Unit. The filename returned is an absolute filename.

    	This command uses the io_Union.io_READ_SOFTLINK member.

\heading{INPUT}
    	io_Unit     	- file to resolve the softlink from
    	io_Buffer   	- buffer to fill with the pathname
    	io_Size     	- size of the buffer. Return ERROR_LINE_TOO_LONG if
    	    	    	  the buffer is not large enough.

\heading{RESULT}
    	The buffer io_Buffer will contain the absolute filename that this
    	link refers to.
    	
    	io_DosError 	- DOS error code, or 0 for success.

\heading{SEE ALSO}
    	FSA_MAKE_SOFTLINK
    	
\subsection{FSA_DELETE_OBJECT}
\heading{NAME}
	FSA_DELETE_OBJECT - Delete an object from the filesystem

\heading{FUNCTION}
	Delete a given file or directory. It is illegal to try and
	delete a directory which contains files - you should return
	ERROR_DIRECTORY_NOT_EMPTY if an attempt is made.

	Files with outstanding handles cannot be deleted.

	If the io_Unit handle is NULL, the file to delete is relative
	to the root of the filesystem.

\heading{INPUT}
	io_Unit		- handle to current directory (or NULL)
	io_Filename	- relative filename

\heading{RESULT}
	io_DosError	- dos error code or 0

\subsection{FSA_SET_COMMENT}
\heading{NAME}
	FSA_SET_COMMENT - Set the comment of an object

\heading{FUNCTION}
	Set a new comment for a file or directory. The maximum length for
	a comment has historically been 80 characters (including NULL
	termination).

\heading{INPUT}
	io_Unit		- handle to current directory
	io_Filename	- relative filename
	io_Comment	- pointer to a C string (STRPTR)

\heading{RESULT}
	The object will have a new comment.

	io_DosError	- dos error code or 0 for success

\subsection{FSA_SET_PROTECT}
\heading{NAME}
	FSA_SET_PROTECT - Set protection bits for a file

\heading{FUNCTION}
	Set the protection bits on a file or directory. Note that there
	are four groups of protection bits.

	    Owner read, write, execute, delete
	    Group read, write, execute, delete
	    Other read, write, execute, delete
	    Pure, Script, Archived

	You should not that the owner bits are handled a bit strangely
	as they are active low (ie 0 means enabled/set).

	Note that if io_Unit is valid (ie non-NULL), and io_Args[0] is
	NULL then you should change the mode of the object described
	by the io_Unit handle.

\heading{INPUT}
	io_Unit		- handle to current directory
	io_Filename	- relative filename
	io_Protection	- new protection bits

\heading{RESULT}
	The object will have new protection bits.

	io_DosError	- dos error code or 0 for success.

\subsection{FSA_SET_OWNER}
\heading{NAME}
	FSA_SET_OWNER - Set the owner of a file

\heading{FUNCTION}
	This command allows a user to set the ownership of files. The
	file should be changed to reflect the new owner of the directory.

	The owner and group fields in the arguments are interpreted as
	32-bit values, however in general, they will only be 16-bit 
	values. If the values are outside the 16-bit range, and you are
	unabled to handle the values then you can return an error.
	The ERROR_BAD_NUMBER appears to be the most appropriate error
	number.

	Special User ID's:
	    0	-	root/Supervisor
	    -1	-	No owner (0x0000FFFF or 0xFFFFFFFF)

	Special Group ID's:
	    0	-	wheel/Supergroup
	    -1	-	No group (0x0000FFFF or 0xFFFFFFFF)

	Typically AmigaOS filesystems have had little multiuser support,
	and it should be expected that few filesystems will actually
	support this command. For security reasons, only the superuser
	or the owner of a file should be allowed to change the ownership.


\heading{INPUT}
	io_Unit		- handle to current directory
	io_Filename	- relative filename
	io_UID		- new user ID
	io_GID		- new group ID

\heading{RESULT}
	The file will now be owned by a different user.

	io_DosError	- dos error code or 0 or success.

\subsection{FSA_SET_DATE}
\heading{NAME}
	FSA_SET_DATE - Set the date of a file/directory

\heading{FUNCTION}
	Set the modification date of a file or directory. If the filesystem
	does not support the date, for example it is too old, then you
	should return ERROR_BAD_NUMBER. It should not be possible to set
	the creation date of an object (except by creating it).

\heading{INPUT}
	io_Unit		- handle to current directory
	io_Filename	- relative filename
    	io_Date     	- struct DateStamp describing new date.

\heading{RESULT}
	The modification date will have been changed.

	io_DosError	- dos error code or 0 for success.

\subsection{FSA_IS_FILESYSTEM}
\heading{NAME}
    	FSA_IS_FILESYSTEM - Ask the filesystem handler if it is a filesystem

\heading{FUNCTION}
    	Query the filesystem as to whether it is a proper filesystem. An 
    	example of something that is not a filesystem is a device handler
    	like PAR:.
    	
    	This command uses the io_Union.io_IS_FILESYSTEM member.

\heading{INPUT}
    	None.

\heading{RESULT}
    	io_IsFilesystem - TRUE if this is a filesystem, FALSE otherwise.
    	io_DosError 	- DOS error code, or 0 for sucecss.

\subsection{FSA_MORE_CACHE}
\heading{NAME}
    	FSA_MORE_CACHE - Add more cache buffers to the filesystem.

\heading{FUNCTION}
    	Add the number io_NumBuffers of cache buffers to the filesystem.
    	The size of the buffer should have been given during the initial
    	filesystem open.
    	
    	If the number of buffers is negative, then the result will be to
    	remove buffers from the device. You can not have less than 0 buffers.
    	
    	This command uses the io_Union.io_MORE_CACHE member.

\heading{INPUT}
    	io_NumBuffers	- The number of buffers to add/remove.

\heading{RESULT}
    	The number of buffers will have been altered if possible.
    	io_NumBuffers	- The new number of buffers in the filesystem. This
    	    	    	  should be returned, even on failure.
    	io_DosError 	- DOS error code, or 0 for success.

\subsection{FSA_FORMAT}
\heading{NAME}
    	FSA_FORMAT - Initialise a filesystem

\heading{FUNCTION}
    	Initialise a device to be used by this filesystem. The device media  
    	should have already been initialised, and this command simply gets
    	the filesystem to write its own data.
    	
    	This command uses the io_Union.io_FORMAT member.

\heading{INPUT}
    	io_VolumeName	- the new name for the volume.
    	io_DosType  	- the new type of the volume. This is filesystem
    	    	    	  specific.

\heading{RESULT}
    	The filesystem will have been initialised, and is ready for mounting.
    	
    	io_DosError 	- DOS error code, or 0 for success.

\subsection{FSA_MOUNT_MODE}
\heading{NAME}
    	FSA_MOUNT_MODE

\heading{FUNCTION}
    	Change or read the mount modes of the volume passed in io_Unit.
    	The mask is used to select which modes are to be changed.
    	
    	This command uses the io_Union.io_MOUNT_MODE member.

\heading{INPUT}
    	io_MountMode	- The new mount mode of the filesystem.
    	io_Mask     	- The mask of flags to change in the mount mode.
    	io_Password 	- The password which is required for MMF_LOCKED.
    	    	    	  It is a good idea not to store this password as
    	    	    	  plain text.

\heading{RESULT}
    	io_MountMode	- The new mount modes of the filesystem.


\end{autodoc}
