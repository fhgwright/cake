#ifndef AROS_MACHINE_H
#define AROS_MACHINE_H
/*
    (C) 1995-96 AROS - The Amiga Replacement OS
    $Id$

    Desc: machine.h include file for Linux/i386 and FreeBSD/i386
    Lang: english
*/


/* We need some types (UBYTE, ULONG, etc) and offsetof() */
#ifndef EXEC_TYPES_H
#   include <exec/types.h>
#endif

/* Information generated by machine.c */
#define AROS_STACK_GROWS_DOWNWARDS 1 /* Stack direction */
#define AROS_BIG_ENDIAN 	   0 /* Big or little endian */
#define AROS_SIZEOFULONG	   4 /* Size of an ULONG */
#define AROS_WORDALIGN		   2 /* Alignment for WORD */
#define AROS_LONGALIGN		   4 /* Alignment for LONG */
#define AROS_PTRALIGN		   4 /* Alignment for PTR */
#define AROS_IPTRALIGN		   4 /* Alignment for IPTR */
#define AROS_DOUBLEALIGN	   4 /* Alignment for double */
#define AROS_WORSTALIGN 	   4 /* Worst case alignment */

/* ??? */
#define SP_OFFSET 0

/*
    Replace BPTRs by simple APTRs for this machine. On Amiga with binary
    compatibility, this would look like this:

    typedef ULONG BPTR;
    #define MKBADDR(a)      (((BPTR)(a))>>2)
    #define BADDR(a)        (((APTR)(a))<<2)
*/
#ifndef __typedef_BPTR
#define __typedef_BPTR
typedef APTR BPTR;
#endif
#define MKBADDR(a)  ((APTR)(a))
#define BADDR(a)    (a)

/*
    One entry in a libraries' jumptable. For assembler compatibility, the
    field jmp should contain the code for an absolute jmp to a 32bit
    address. There are also a couple of macros which you should use to
    access the vector table from C.
*/
struct JumpVec
{
    UBYTE jmp;
    UBYTE vec[4];
};
/* Internal macros */
#define __AROS_ASMJMP			0xE9
#define __AROS_SET_VEC(v,a)             (*(ULONG*)(v)->vec=(ULONG)(a)-(ULONG)(v)-5)
#define __AROS_GET_VEC(v)               ((APTR)(*(ULONG*)(v)->vec+(ULONG)(v)+5))

/* Use these to acces a vector table */
#define LIB_VECTSIZE			(sizeof (struct JumpVec))
#define __AROS_GETJUMPVEC(lib,n)        ((struct JumpVec *)(((UBYTE *)lib)-(n*LIB_VECTSIZE)))
#define __AROS_GETVECADDR(lib,n)        (__AROS_GET_VEC(__AROS_GETJUMPVEC(lib,n)))
#define __AROS_SETVECADDR(lib,n,addr)   (__AROS_SET_VEC(__AROS_GETJUMPVEC(lib,n),(APTR)(addr)))
#define __AROS_INITVEC(lib,n)           __AROS_GETJUMPVEC(lib,n)->jmp = __AROS_ASMJMP, \
					__AROS_SETVECADDR(lib,n,_aros_not_implemented)

/* ??? */
#define RDFCALL(hook,data,dptr) ((void(*)(UBYTE,APTR))(hook))(data,dptr);

/*
    Find the next valid alignment for a structure if the next x bytes must
    be skipped.
*/
#define AROS_ALIGN(x)        (((x)+AROS_WORSTALIGN-1)&-AROS_WORSTALIGN)

/* Prototypes */
extern void _aros_not_implemented (void);

/* How much stack do we need ? Lots :-) */
#define AROS_STACKSIZE	100000

#endif /* AROS_MACHINE_H */
