#ifndef _MACHINE_H_
#define _MACHINE_H_
/*
    (C) 1995-96 AROS - The Amiga Replacement OS
    $Id$
*/

/* We need some types (UBYTE, ULONG, etc) and offsetof() */
#ifndef EXEC_TYPES_H
#   include <exec/types.h>
#endif
#include <stddef.h>

/* Information generated by machine.c */
#define AROS_STACK_GROWS_DOWNWARDS 1 /* Stack direction */
#define AROS_BIG_ENDIAN            1 /* Big or little endian */
#define AROS_SIZEOFULONG           4 /* Size of an ULONG */
#define AROS_WORDALIGN             2 /* Alignment for WORD */
#define AROS_LONGALIGN             2 /* Alignment for LONG */
#define AROS_PTRALIGN              2 /* Alignment for PTR */
#define AROS_IPTRALIGN             2 /* Alignment for IPTR */
#define AROS_DOUBLEALIGN           2 /* Alignment for double */
#define AROS_WORSTALIGN            8 /* Worst case alignment */

/*
    How much do I have to add to sp to get the address of the first
    byte on the stack?
*/
#define SP_OFFSET 0

#ifndef __typedef_BPTR
#define __typedef_BPTR
typedef ULONG BPTR;
#endif
#define MKBADDR(a)	((BPTR)(a))
#define BADDR(a)	((APTR)(a))

/*
    One entry in a libraries' jumptable. For assembler compatibility, the
    field jmp should contain the code for an absolute jmp to a 32bit
    address. There are also a couple of macros which you should use to
    access the vector table from C.
*/
struct JumpVec
{
    UWORD jmp;
    APTR  vec;
};

/* Internal macros */
#define __AROS_ASMJMP			0x4ef9
#define __AROS_SET_VEC(v,a)             (*(ULONG*)(v)->vec=(ULONG)(a))
#define __AROS_GET_VEC(v)               ((APTR)(*(ULONG*)(v)->vec))

/* Use these to acces a vector table */
#define LIB_VECTSIZE			(sizeof (struct JumpVec))
#define __AROS_GETJUMPVEC(lib,n)        ((struct JumpVec *)(((UBYTE *)lib)-(n*LIB_VECTSIZE)))
#define __AROS_GETVECADDR(lib,n)        (__AROS_GET_VEC(__AROS_GETJUMPVEC(lib,n)))
#define __AROS_SETVECADDR(lib,n,addr)   (__AROS_SET_VEC(__AROS_GETJUMPVEC(lib,n),(APTR)(addr)))
#define __AROS_INITVEC(lib,n)           __AROS_GETJUMPVEC(lib,n)->jmp = __AROS_ASMJMP, \
					__AROS_SETVECADDR(lib,n,_aros_not_implemented)

#ifdef __GNUC__

/* Try to avoid linking with special 32 bit code */
#define UDIVMOD10(v,q,r)        \
{ asm("movel %2,%0   ;"         \
      "clrw  %0      ;"         \
      "swap  %0      ;"         \
      "divu  #10:W,%0;"         \
      "movel %0,%1   ;"         \
      "movew %2,%1   ;"         \
      "swap  %0      ;"         \
      "divu  #10:W,%1;"         \
      "movew %1,%0   ;"         \
      "clrw  %1      ;"         \
      "swap  %1      ;"         \
      :"=&d"(q),"=&d"(r):"r"(v) \
    );				\
}

/* ??? */
#define RDFCALL(hook,data,dptr)                     \
{						    \
    register unsigned char __d0 __asm("d0") = data; \
    register void *	   __a3 __asm("a3") = dptr; \
    asm volatile("jsr %1@"                          \
	:"=r"(__a3)                                 \
	:"a"(hook),"0"(__a3),"r"(__d0)              \
	:A0,A1,D0,D1,"memory");                     \
    dptr = __a3;				    \
}

#endif

#ifndef UDIVMOD10
#define UDIVMOD10(v,q,r) { ULONG a=v; q=a/10ul; r=a%10ul; }
#endif

/*
    Find the next valid alignment for a structure if the next x bytes must
    be skipped.
*/
#define AROS_ALIGN(x)        (((x)+AROS_WORSTALIGN-1)&-AROS_WORSTALIGN)

/* Prototypes */
extern void _aros_not_implemented (void);

/* How much stack do we need ? Lots :-) */
#define AROS_STACKSIZE	100000

#endif /* _MACHINE_H_ */
