\begin{new}{16.10.1997}
\chapter{Random Ideas}
\section{Introduction}

This part of the documentation for AROS contains random and unsorted and
possibly impossible improvements, ideas and other things which might
go into AROS V2.x, when compatibility with AmigaOS is still important but
where new things can be done.

\begin{itemize}
\item By Nils Henrik Lorentzen: All lists and public structures must be protected by semaphore. A
system like the hierarchical semaphores in pOS would be best.
\item By Claus Herrmann and Iain Templeton:
lddaemon should be able to load more than one library at a time thus
allowing to open a library which has to be loaded from disk which opens a
library in |libOpen()| which has also to be loaded from disk.

The daemon could also search actively for a library allowing the user to
specify one if it can't be found. Paths like \shell{PROGDIR:} should be
searched automatically.

If the lib can't be found, DOS_OpenLibrary() must create a message port and
a message, put the port in the reply-to field of the message as well as the
name and min-version of the lib and then send the message to the lddaemon
and wait for the reply.

Open questions: Will this interfere with the way Exec handles libraries now
(eg. single threaded |libInit()|) ? Can this introduce deadlocks in the
locking of the exec library list ? What happens if |libClose()| calls
|libExpunge()| ?
\item
\begin{new}{27.10.1997}
By Nils Henrik Lorentzen: Extend on the
datatypes concept. Some datatypes-alike system where dataprocessing methods
can be added to datatype classes. (Eg. for pictures one could add methods
like |Rotate()|, |Flip()| and other typical image processing operators.
Similarly one can add sound fx methods for sound data). For this to be
usefull one should probably be able to add methods to a class one by one
(so BOOPSI can probably not be used for this).

The objects should contain the data in a raw format so that the methods
can easily operate on it. One should be able to stream data in and out
of the objects. One could have separate "converter objects" that
can convert from a data format (eg. GIF->internal raw image format
and back eg. raw->GIF.) So when you want to put a GIF file into
an image object the system will automatically search for installed
gif->internal raw converters and convert the GIF into a stream of
raw image data passed to the image object.

These data objects should of course have methods like |Show()|
and |Edit()|. |Edit()| could invoke your favourite
texteditor/paintprogram/drawprogram/etc depending on the
object type. (text/image/structured drawing).

Now, should these objects be able to show themselves,
like the old datatypes ? Well, IMO they should not be bound to
a single operating system/GUI system, but they could maybe show
themselves through some RTG system (?).
But the viewer could also stream out the data from
the object to show. When the object's data has changed, the
viewer could be notified and where in the stream the "damaged" data is.
(If a text viewer GUI views the first 100 lines of a 100000 line
text data object, and the last 100 lines are changed, it wouldn't
need to rerender).

As mentioned earlier one should be able to use this system
on different OSes, and it should maybe also be possible to
invoke methods on them over a network or even move the objects
in a network (using CORBA ?). This way a heavy operation on
the data object can be done on a faster machine while you are
controlling it from a slower machine.

By keeping functionality into small components, 3rd party
programmers can easily write freeware additional functionality.
(One can add methods operating on the data one at a time.)
It will provide very much reuse of code. (Just look around on
Aminet: There are whole bunch of different image processing
programs that implement the same functionality. This
should really only have to be written once).
If the system can work on other platforms too, we get even
more developers that can support it.

I believe that if some system should have any chance at all
of taking some market share from M$ it	a) has to be free.
b) must be available on as many platforms as possible. c) must consist
of tiny components that can be added at run-time.=>This way it'll be
easier for developers to support it.
\end{new}

\item
\begin{new}{27.10.1997}
By Aaron Digulla:
When a new HIDD is installed, it should appear in the list of
available HIDDs automatically (eg. by file notification on the directory).
\end{new}

\item
\begin{new}{27.10.1997}
By Aaron Digulla:
We need an automatic converter for the incompatible features of AROS
to convert the old AmigaOS code to AROS (which can then be compiled on
AmigaOS by our compatibility lib).
\end{new}

\item
\begin{new}{3.11.1997}
By Bernhard Fastenrath:
I wanted to have a select() for AmigaOS filedescriptors some time ago, that's
why I wrote the AbortPkt() patch which sends an ACTION_ABORT.

A select/asyncio handler (AsyncIO.hidd ?) which handles allocation of buffers
and IO on multiple handlers could allocate buffers, do multiple reads on behalf
of a process and signal the process when input is available. The same would
happen for write operations (writing would block when the select handler has
queued a maximum of bytes or buffers for a single process).

A process that wants to exit could just close the select handler and leave it
to the handler to deallocate the buffers when they are returned one day ...
Under AROS the handler would be able to use AbortPkt() and under AmigaOS it
would be able to use it if the patch is installed and the underlying handler
accepts the packet type ACTION_ABORT.

The idea reminds me a bit of Unix STREAMS or NT device drivers: both pass
packets through several layers of device abstractions. UnixIO could be one
layer below the select handler and would translate it to a real select()
because the buffer mechanism of the select handler is part of the Unix kernel
anyway; so a write would block when the kernel buffers are full, as usual.
\end{new}

\item
\begin{new}{18.11.1997}
By Aaron Digulla:
I'm thinking about something called "cache memory". It should use all free
memory to store "nice to have" data like for read ahead or write through
caches for disks and harddisk or a printer spooler.

This memory is allocated by special functions. It doesn't appear in the
"memory used" list but is added to the amount of free memory. Besides
allocation and freeing there are two special cases. The simple one is that
some other application needs the RAM, so parts of the cache have to be
purged. The other one is to avoid memory fragmentation. It's not possible
or useful to use all the free memory for caching. So the cache should
always be one large block divided up in several smaller chunks. If an
application needs memory, parts of the cache have to be freed *or* they
have to be copied in unused chunks (eg. it's still faster to copy 512 bytes
than to read them back from HD or a printer spooler should not throw the
spooled data away).
\end{new}

\item
\begin{new}{19.1.1998}
By Paulo F. Zemek:
The Amiga
has the Smart refreshed windows that uses an own bitmap and the Simple, that
need to be refreshed because it uses the screen bitmap. I want a Double
Buffered one. A simple refresh window where you allocate a bitmap and a
rastport for it, and this will be send to window on Refresh (or in window's
BackFill Hook) and when the Draw of All Buttons are finished, so you don't
get "flickering" (I don't know the correct word) on the graphic, and uses
almost the same memory of a Smart one.
\end{new}

\item
\begin{new}{19.1.1998}
By Paulo F. Zemek:
The amiga needs a function for opening windows into other windows like on
windows. The "Requester" does this, but stops the functionality of the
window, and doesn't have all Attributes of a real window. This or something
like this is needed for buttons which are over others, so the graphic of the
"bottom" one will not pass over the front one. And can be created new
functions for opening Windows/Screens, so you can convert a window into a
screen, create Public Windows and open other windows on it...

[Aaron Digulla: This is dangerous; it uses a lot of memory, adds many
IDCMP event loops and the same effect can be achieved when using
clip regions; all we have to do is to make the gadgets public, which render a
window, plus maybe a BOOPSI subwindow class which installs a clip region
in another window.]
\end{new}

\item
\begin{new}{19.1.1998}
By Paulo F. Zemek:
exec.library can have an EnqueueTail, and this
is easy to do, so the Enqueue already exists.
\end{new}

\item
\begin{new}{19.1.1998}
By Paulo F. Zemek:
Intuition should not send more than one REFRESH message to a window (ie.
if there is already one in the queue, then it should be removed first).
\end{new}

\item
\begin{new}{5.3.1998}
By Denis Bucher:
|OpenLibrary()|, etc. should check for libraries in various places.
It should be possible to add paths for these and similar functions
and there should be a tool which checks and tells which library, etc.
would be opened (eg. the path is \shell{libs,PROGDIR:libs,libs:} and there
is a \filename{x.library} in \filename{libs} and \filename{libs:}. The tool
should tell which one
is opened and why (ie. \shell{loading libs:x.library over libs/x.library
because: libs:x.library has version 41.0 and libs/x.library has
39.20}).
\end{new}

\begin{new}{5.3.1998}
By Aaron Digulla:
It should be possible to protect some files (like libraries) so
that you need to call a specific OS/FS function to replace them.
This would allow to fix all problems with tools replacing libraries
with old versions. Maybe even a patch to |Open()| would be enough
which checks if someone tries to write in a specific directory
and calls a tool which checks if the write is ok. This is of course
a bit dangerous.
\end{new}

\item
\begin{new}{05.03.1998}
By Henning Kiel:
The original Amiga Includes used to have an intuition/iobsolete.h
AROS wants to get rid of obsolete stuff, and therefore we are not going
to include iobsolete.h in our distribution. However, we are intersted in
getting software for AROS and this may be old, but useful.
So we need a way to support old sources, but in such a way, that the old
code will be converted. (Maybe in multiple passes)
This conversion-tool should do: (open, unordered list)
\begin{itemize}
\item convert old defines to new ones
\item convert old storage types (e.g. SHORT to WORD)
\end{itemize}
\end{new}

\end{itemize}
\end{new}
