/*
    (C) 1995-98 AROS - The Amiga Replacement OS
    $Id$

    Desc: Archive of MathFFP Libraries basic math functions
    Lang: english
*/
#Archive
#Header
#include <libraries/mathffp.h>
#include <aros/libcall.h>
#include <proto/mathffp.h>
#include <proto/exec.h>
#include <exec/types.h>
#include "mathffp_intern.h"
#/Header

#Function LHA float SPAdd
#Parameter float fnum1 D1
#Parameter float fnum2 D0
#LibOffset 11

#AutoDoc
#Function Calculate the sum of two ffp numbers

#Inputs
#Item fnum1  - ffp number to add
#Item fnum2  - ffp number to add
#/Inputs

#Result
sum of fnum1 and fnu2
<linebreak>
<preformatted>
        Flags:
          zero     : result is zero
          negative : result is negative
          overflow : result is too large or too small for ffp format
</preformatted>
#/Result

#Notes

#Example

#Bugs

#SeeAlso

#Internals
<boldface>ALGORITHM:</boldface>
<linebreak>
Adapt the exponent of the ffp-number with the smaller
exponent to the ffp-number with the larger exponent.
Therefore rotate the mantisse of the ffp-number with the
smaller exponents by n bits, where n is the absolute value
of the difference of the exponents.
<linebreak>
The exponent of the target ffp-number is set to the larger
exponent plus 1.
<linebreak>
Additionally rotate both numbers by one bit to the right so
you can catch a result >1 in the MSB.
<linebreak>
If the signs of the two numbers are equal then simply add
the two mantisses. The result of the mantisses will be
[0.5 .. 2[. Check the MSB. If zero, then the result is < 1
and therefore subtract 1 from the exponent. Normalize the
mantisse of the result by rotating it one bit to the left.
Check the mantisse for 0.
<linebreak>
If the signs of the two numbers are different then subtract
the ffp-number with the neagtive sign from the other one.
The result of the mantisse will be [-1..1[. If the MSB of
the result is set, then the result is below zero and therefore
you have to calculate the absolute value of the mantisse.
Check the mantisse for zero. Normalize the mantisse by
rotating it to the left and decreasing the exponent for every
rotation.
<linebreak>
Test the exponent of the result for an overflow.
<linebreak>
That`s it!
#/Internals
#History
#/AutoDoc

#Code
{
  LONG Res;
  ULONG Mant1, Mant2;
  char Shift;
  char Exponent;

  SetSR(0, Zero_Bit | Overflow_Bit | Negative_Bit );

  Mant1 = fnum1 & FFPMantisse_Mask;
  Mant2 = fnum2 & FFPMantisse_Mask;
  Shift = ((char)fnum1 & FFPExponent_Mask) -
          ((char)fnum2 & FFPExponent_Mask);

  if (Shift > 0)
  {
    if (Shift >= 31)
      Mant2 = 0;
    else
      Mant2 >>= (Shift + 1);
    Mant1 >>= 1;
    Exponent = (fnum1 & FFPExponent_Mask) + 1;
  }
  else
  {
    if (Shift <= -31)
      Mant1 = 0;
    else
      Mant1 >>= (-Shift + 1);
    Mant2 >>= 1;
    Exponent = (fnum2 & FFPExponent_Mask) + 1;
  }

  /* sign(fnum1) == sign(fnum2)
  ** simple addition
  ** 0.5 <= res < 2
  */
  if ( ((BYTE) fnum1 & FFPSign_Mask) - ((BYTE) fnum2 & FFPSign_Mask) == 0)
  {
    Res = fnum1 & FFPSign_Mask;
    Mant1 += Mant2;
    if ((LONG) Mant1 > 0)
    {
      Exponent --;
      Mant1 +=Mant1;
    }

    if (0 == Mant1)
    {
      SetSR(Zero_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
      return 0;
    }
  }
    /* second case: sign(fnum1) != sign(fnum2)
    ** -1 <= res < 1
    */
  else
  {
    if ((char) fnum1 < 0)
      Mant1 = Mant2 - Mant1;
    else /* fnum2 < 0 */
      Mant1 = Mant1 - Mant2;
    /* if the result is below zero */
    if ((LONG) Mant1 < 0)
    {
      Res = FFPSign_Mask;
      Mant1 =-Mant1;
      SetSR(Negative_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    }
    else
      Res = 0;
      
    /* test the result for zero, has to be done before normalizing
    ** the mantisse
    */
    if (0 == Mant1)
    {
      SetSR(Zero_Bit, Zero_Bit | Overflow_Bit | Negative_Bit);
      return 0;
    }
    /* normalize the mantisse */
      while ((LONG) Mant1 > 0)
      {
        Mant1 += Mant1;  /* one bit to the left. */
        Exponent --;
      }

  } /* else */

  if ((char) Exponent < 0)
  {
    SetSR(Overflow_Bit, Zero_Bit | Overflow_Bit);
    /* do NOT change Negative_Bit! */
    return (Res | (FFPMantisse_Mask | FFPExponent_Mask));
  }

  Res |= (Mant1 & FFPMantisse_Mask) | Exponent;
  return Res;
}
#/Code
#/Function


#Function LHA float SPDiv
#Parameter float fnum1 D1
#Parameter float fnum2 D0
#LibOffset 14

#AutoDoc
#Function
Divide two ffp numbers
<linebreak>
fnum = fnum2 / fnum1;
#/Function

#Inputs
#Item fnum1 - ffp number
#Item fnum2 - ffp number
#/Inputs

#Result
<linebreak>
<preformatted>
        Flags:
          zero     : result is zero
          negative : result is negative
          overflow : result is out of range
</preformatted>
#/Result

#Bugs The parameters are swapped !

#Internals
<boldface>ALGORITHM:</boldface>
<newline>
Check if fnum2 == 0: result = 0;
<newline>
Check if fnum1 == 0: result = overflow;
<newline>
The further algorithm comes down to a pen & paper division
#/Internals
#/AutoDoc

#Code
{
  LONG Res = 0;
  char Exponent = ((char) fnum2 & FFPExponent_Mask) -
                  ((char) fnum1 & FFPExponent_Mask) + 0x41;

  LONG Mant2 = ((ULONG)fnum2 & FFPMantisse_Mask);
  LONG Mant1 = ((ULONG)fnum1 & FFPMantisse_Mask);
  ULONG Bit_Mask = 0x80000000;

  /* check if the dividend is zero */
  if (0 == fnum2)
  {
    SetSR(Zero_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    return 0;
  }

  /* check for division by zero */
  if (0 == fnum1)
  {
    SetSR(Overflow_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    return 0;
  }

  while (Bit_Mask >= 0x40 && Mant2 != 0)
  {
    if (Mant2 - Mant1 >= 0)
    {
      Mant2 -= Mant1;
      Res |= Bit_Mask;

      while (Mant2 > 0)
      {
        Mant2 <<= 1;
        Bit_Mask >>= 1;
      }

      while (Mant1 > 0)
      {
        Mant1 <<=1;
        Bit_Mask <<=1;
      }
    } /* if */
    else
    {
      Mant1 = (ULONG) Mant1 >> 1;
      Bit_Mask >>= 1;
    }
  } /* while */

  /* normalize the mantisse */
  while (Res > 0)
  {
    Res += Res;
    Exponent --;
  }

  if ((char) Res < 0)
    Res += 0x00000100;

  Res &= FFPMantisse_Mask;
  Res |= (Exponent & 0x7f);
  Res |= (fnum1 & FFPSign_Mask) ^ (fnum2 & FFPSign_Mask);

  if ((char) Res < 0)
    SetSR(Negative_Bit, Zero_Bit | Overflow_Bit | Negative_Bit);

  if ((char) Exponent < 0)
  {
    SetSR(Overflow_Bit, Zero_Bit | Overflow_Bit | Negative_Bit);
    return(Res | (FFPMantisse_Mask | FFPExponent_Mask));
  }
  return Res;
}
#/Code
#/Function


#Function LHA float SPMul
#Parameter float fnum1 D1
#Parameter float fnum2 D0
#LibOffset 13

#AutoDoc
#Function
Multiply two ffp numbers
<linebreak>
fnum = fnum1 * fnum2;
#/Function

#Inputs
#Item fnum1 - ffp number
#Item fnum2 - ffp number
#/Inputs

#Result
<linebreak>
<preformatted>
        Flags:
          zero     : result is zero
          negative : result is negative
          overflow : result is out of range
</preformatted>
#/Result
#/AutoDoc

#Code
{
  char Exponent = ((char) fnum1 & FFPExponent_Mask) +
                  ((char) fnum2 & FFPExponent_Mask) - 0x41;
  ULONG Mant1H = ( (ULONG) (fnum1 & FFPMantisse_Mask)) >> 20;
  ULONG Mant2H = ( (ULONG) (fnum2 & FFPMantisse_Mask)) >> 20;
  ULONG Mant1L = (((ULONG) (fnum1 & FFPMantisse_Mask)) >> 8) & 0x00000fff;
  ULONG Mant2L = (((ULONG) (fnum2 & FFPMantisse_Mask)) >> 8) & 0x00000fff;
  LONG Res;

  Res  =  (Mant1H * Mant2H) <<  8;
  Res += ((Mant1H * Mant2L) >>  4);
  Res += ((Mant1L * Mant2H) >>  4);
  Res += ((Mant1L * Mant2L) >> 16);

  /* Bit 32 is not set */
  if ((LONG)Res > 0)
    Res <<= 1; /* rotate the mantisse by one bit to the left */
  else
    Exponent ++;


  if (0 == Res)
  {
    SetSR(Zero_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    return 0;
  }

  Res |= ((fnum1 & FFPSign_Mask) ^ (fnum2 & FFPSign_Mask) );

  /* overflow? */
  if ((char) Exponent < 0 || (char) Exponent == 0x7f)
  {
    SetSR(Overflow_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    return (Res | (FFPMantisse_Mask + FFPExponent_Mask));
  }

  Res |= Exponent;

  if ((char) Res < 0)
    SetSR(Negative_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);

  return Res;
}
#/Code
#/Function


#Function LHA float SPNeg
#Parameter float fnum1 D0
#LibOffset 10

#AutoDoc
#Function Calculate fnum1*(-1)

#Inputs
#Item fnum1 - ffp number
#/Inputs

#Result
-fnum1
<linebreak>
<preformatted>
        Flags:
          zero     : result is zero
          negative : result is negative
          overflow : 0
</preformatted>
#/Result

#Internals
<boldface>ALGORITHM:</boldface>
#Item Return zero if fnum == 0.
#Item Otherwise flip the sign-bit.
#/Internals
#/AutoDoc

#Code
{
  if (0 == fnum1)
  {
    SetSR( Zero_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    return 0;
  }

  /* flip sign-bit */
  fnum1 ^= FFPSign_Mask;

  if((char) fnum1 < 0)
  /* result is negative */
    SetSR(Negative_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
  else
    /* result is positive */
    SetSR(0, Zero_Bit | Overflow_Bit | Negative_Bit );

  return fnum1;
}
#/Code
#/Function


#Function LHA float SPSub
#Parameter float fnum1 D0
#LibOffset 12

#AutoDoc
#Function
Subtract two floating point numbers
<linebreak>
fnum = fnum2 - fnum1;
#/Function

#Inputs
#Item fnum1  - ffp number
#Item fnum2  - ffp number
#/Inputs

#Result
-fnum1
<linebreak>
<preformatted>
        Flags:
          zero     : result is zero
          negative : result is negative
          overflow : result is out of range
</preformatted>
#/Result

#Internals
<boldface>ALGORITHM:</boldface>
#Item fnum = fnum2 + (-fnum1).
#/Internals
#/AutoDoc

#Code
{
  return SPAdd(fnum2, fnum1 ^ FFPSign_Mask);
}
#/Code
#/Function


#/Archive

