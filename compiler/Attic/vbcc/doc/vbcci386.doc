vbcc - C compiler (c) in 1995-97 by Volker Barthelmann


INTRODUCTION

    vbcc is a free portable and retargetable ANSI C compiler.
    It is clearly split into a target independant and a target dependant
    part and supports emulating datatypes of the target machine on any
    other machine so that it is possible to e.g. make a crosscompiler for
    a 64bit machine on a 32bit machine.
    This document only deals with the target dependant parts of the
    i386 version.


LEGAL

    vbcc is (c) in 1995-97 by Volker Barthelmann. All code is written by me
    and may be freely redistributed as long as no modifications are made
    and nothing is charged for it.
    Non-commercial usage of vbcc is allowed without any restrictions.
    Commercial usage needs my written consent.

    Sending me money, gifts, postcards etc. would of course be very nice
    and may encourage further development of vbcc, but is not legally or
    morally necessary to use vbcc.


ADDITIONAL OPTIONS FOR THIS VERSION

    -longalign  Align multibyte-values on 4-byte-boundaries. Needed by some
                operating systems.

    -elf        Do not use a '_'-prefix in front of external identifiers.
                Use a '.'-prefix for label names.

    -merge-constants

                Place identical floating point constants at the same
                memory location. This can reduce program size and increase
                compilation time.

    -const-in-data

                By default constant data will be placed in the code
                section (and therefore is accessable with faster pc-relative
                addressing modes). Using this option it will be placed in the
                data section.
                Note that on operating systems with memory protection this
                option will disable write-protection of constant data.

    -no-delayed-popping

                By default arguments of function calls are not always popped
                from the stack immediately after the call, so that the
                arguments of several calls may be popped at once.
                With this option vbcc can be forced to pop them after every
                function call.
                This may simplify debugging and very slightly reduce the
                stack size needed by the compiled program.

    -safe-fp    Do not use the floating-point-stack for register variables.
                At the moment this is necessary as vbcci386 still has problems
                in some cases otherwise.


SOME INTERNALS

    The current version generates assembly output for use with the GNU
    assembler. The generated code should work on systems with Intel 80386
    or higher CPUs with FPU.

    The register names are:

        %eax, %ebx, %ecx, %edx
        %esi, %edi, %ebp, %esp

        (and %st(0)-%st(7) for the floating point stack but you must not
         use it for register variables because it cannot be handled like
         normal registers)

    The registers %eax, %ecx and %edx (as well as the floating point stack)
    are used as scratch registers (i.e. they can be destroyed in function
    calls), all other registers are preserved.

    All elementary types up to 4 bytes are returned in register %eax
    Floating point values are returned in %st(0).
    All other types are returned by passing the function the address
    of the result as a hidden argument - so when you call such a function
    without a proper declaration in scope you can expect a crash.

    vbcc uses %eax, %ebx, %ecx, %edx, %esi, %edi, %ebp and the floating point
    stack for temporary results and register variables. Local variables
    are created on the stack and addressed via %esp.

    The elementary data types are represented like:

    type        size in bits        alignment in bytes(with -longalign)

    char                8                       1
    short              16                       2(4)
    int                32                       2(4)
    long               32                       2(4)
    all pointers       32                       2(4)
    float              32                       2(4)
    double             64                       2(4)


STDARG

    A possible <stdarg.h> could look like this:

    typedef unsigned char *va_list;

    #define va_start(ap, lastarg) ((ap) = (va_list)(&lastarg + 1))
    #define va_arg(ap, type) ((ap) += \
      (sizeof(type)<sizeof(int)?sizeof(int):sizeof(type)), ((type *)(ap))[-1])
    #define va_end(ap) ((ap) = 0L)


KNOWN PROBLEMS

    - generated code is not very good
    - functions which return floating-point values don't work


Volker Barthelmann                                      volker@vb.franken.de
Kennedy-Ring 39
91301 Forchheim
Germany

